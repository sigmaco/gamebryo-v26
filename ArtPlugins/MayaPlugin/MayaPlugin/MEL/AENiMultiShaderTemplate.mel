source GamebryoStackTracer;
//AENiMultiShaderTemplate.mel

global proc AENiMultiShaderMapButtonNew(string $attrName, string $labelName)
{
Cr8zyTracerIn("AENiMultiShaderMapButtonNew", {"$attrName", "$labelName"}, {"" + $attrName, "" + $labelName});
	string $buffer2[];
	tokenize $labelName "." $buffer2;
	
	string $buffer[];
	tokenize $attrName "." $buffer;
	
	$justAttrName  = `interToUI($buffer2[1])`;
	if($justAttrName == "")
	{
		$justAttrName = `interToUI($buffer[1])`;
	}

	attrNavigationControlGrp -at $attrName -label $justAttrName $buffer[1]; 
Cr8zyTracerOut("AENiMultiShaderMapButtonNew", "", "");
}

global proc AENiMultiShaderMapButtonReplace(string $attrName, string $labelName)
{
Cr8zyTracerIn("AENiMultiShaderMapButtonReplace", {"$attrName", "$labelName"}, {"" + $attrName, "" + $labelName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justAttrName = `interToUI($buffer[1])`;
	
	attrNavigationControlGrp -e -at $attrName $buffer[1]; 
Cr8zyTracerOut("AENiMultiShaderMapButtonReplace", "", "");
}

global proc AENiMultiShaderColorOnlyNew(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderColorOnlyNew", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justAttrName = `interToUI($buffer[1])`;
		
	attrColorSliderGrp -l $justAttrName -at $attrName -sb 0 ($buffer[1] + "_Control");

Cr8zyTracerOut("AENiMultiShaderColorOnlyNew", "", "");
}

global proc AENiMultiShaderColorOnlyReplace(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderColorOnlyReplace", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justAttrName = `interToUI($buffer[1])`;
	
	attrColorSliderGrp -e -at $attrName -sb 0 ($buffer[1] + "_Control");
Cr8zyTracerOut("AENiMultiShaderColorOnlyReplace", "", "");
}

global proc AENiMultiShaderControlNoMapNew(string $attrName, string $labelName)
{
Cr8zyTracerIn("AENiMultiShaderControlNoMapNew", {"$attrName", "$labelName"}, {"" + $attrName, "" + $labelName});
	string $buffer2[];
	tokenize $labelName "." $buffer2;
	
	string $buffer[];
	tokenize $attrName "." $buffer;
	
	$justAttrName  = `interToUI($buffer2[1])`;
	if($justAttrName == "")
	{
		$justAttrName = `interToUI($buffer[1])`;
	}
	
	attrControlGrp -l $justAttrName -a $attrName -hmb 1 ($buffer[1] + "_Control");
Cr8zyTracerOut("AENiMultiShaderControlNoMapNew", "", "");
}

global proc AENiMultiShaderControlNoMapReplace(string $attrName,  string $labelName)
{
Cr8zyTracerIn("AENiMultiShaderControlNoMapReplace", {"$attrName", "$labelName"}, {"" + $attrName, "" + $labelName});
	string $buffer2[];
	tokenize $labelName "." $buffer2;
	
	string $buffer[];
	tokenize $attrName "." $buffer;
	
	$justAttrName  = `interToUI($buffer2[1])`;
	if($justAttrName == "")
	{
		$justAttrName = `interToUI($buffer[1])`;
	}
	
	attrControlGrp -e -a $attrName -hmb 1 ($buffer[1] + "_Control");
Cr8zyTracerOut("AENiMultiShaderControlNoMapReplace", "", "");
}

global proc AENiMultiShaderResolutionControlNew(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderResolutionControlNew", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justAttrName = `interToUI($buffer[1])`;
	
	attrControlGrp -label "In Maya Texture Size" -a $attrName -hmb 1 ($buffer[1] + "_Control");
Cr8zyTracerOut("AENiMultiShaderResolutionControlNew", "", "");
}

global proc AENiMultiShaderResolutionControlReplace(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderResolutionControlReplace", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justAttrName = `interToUI($buffer[1])`;
	
	attrControlGrp -e -a $attrName -hmb 1 ($buffer[1] + "_Control");
Cr8zyTracerOut("AENiMultiShaderResolutionControlReplace", "", "");
}



global proc AENiMultiShaderAlphaNew(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderAlphaNew", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justNodeName = $buffer[0];
	string $cmd = ("AEaimMaterialAlphaOverride " + $justNodeName);

    if(`colorSliderGrp -ex ("MaterialAlpha_Control")`)
    {
        deleteUI ("MaterialAlpha_Control");
    }

	colorSliderGrp -label "Material Alpha" -cc $cmd ("MaterialAlpha_Control");
	
Cr8zyTracerOut("AENiMultiShaderAlphaNew", "", "");
}

global proc AENiMultiShaderAlphaReplace(string $attrName)
{
Cr8zyTracerIn("AENiMultiShaderAlphaReplace", {"$attrName"}, {"" + $attrName});
	string $buffer[];
	tokenize $attrName "." $buffer;
	string $justNodeName = $buffer[0];
	string $cmd = ("AEaimMaterialAlphaOverride " + $justNodeName);

    float $materialAlpha[] = `getAttr ($justNodeName + ".outTransparency")`;
    
    print($materialAlpha);

	colorSliderGrp -e -cc $cmd ("MaterialAlpha_Control");

    colorSliderGrp -e -rgbValue $materialAlpha[0] $materialAlpha[1] $materialAlpha[2] "MaterialAlpha_Control";
Cr8zyTracerOut("AENiMultiShaderAlphaReplace", "", "");
}

//***************************************************************************
global proc AENiMultiShaderTemplate( string $nodeName )
{
Cr8zyTracerIn("AENiMultiShaderTemplate", {"$nodeName"}, {"" + $nodeName});
    AEswatchDisplay $nodeName;

    editorTemplate -callCustom AEshaderTypeNew AEshaderTypeReplace "message";

    // Put our attributes into a scrolled layout field
    editorTemplate -beginScrollLayout;


    // The all go into the collapsable "Parameters" section

    //***************************************************************************
    editorTemplate -beginLayout "Performance" -collapse false;

        editorTemplate -label "Single Map Only" -addControl "BaseMapOnly" "MyImmerseResetNiMultiShaderBaseMapOnly";

        editorTemplate -label "Selected Texture" -addControl "SelectedTexture" "MyImmerseResetNiMultiShaderBaseMapOnly";

        // Add the default controls for the scale and frames attributes
        editorTemplate -callCustom "AENiMultiShaderResolutionControlNew" "AENiMultiShaderResolutionControlReplace" "resolution";
	editorTemplate -suppress "resolution";

    editorTemplate -endLayout;

    //***************************************************************************
    editorTemplate -beginLayout "Material" -collapse false;

        editorTemplate -callCustom "AENiMultiShaderColorOnlyNew" "AENiMultiShaderColorOnlyReplace" "MaterialDiffuse";
	editorTemplate -suppress "MaterialDiffuse";
        editorTemplate -callCustom "AENiMultiShaderColorOnlyNew" "AENiMultiShaderColorOnlyReplace" "MaterialSpecular";
	editorTemplate -suppress "MaterialSpecular";
        editorTemplate -callCustom "AENiMultiShaderColorOnlyNew" "AENiMultiShaderColorOnlyReplace" "MaterialAmbient";
	editorTemplate -suppress "MaterialAmbient";
        editorTemplate -callCustom "AENiMultiShaderColorOnlyNew" "AENiMultiShaderColorOnlyReplace" "MaterialEmittance";
	editorTemplate -suppress "MaterialEmittance";
 //       editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "MaterialShineness" "";
	//editorTemplate -suppress "MaterialShineness";
    editorTemplate -label "Material Shineness" -addControl "MaterialShineness";

        editorTemplate -callCustom "AENiMultiShaderAlphaNew" "AENiMultiShaderAlphaReplace" "transparency";
	editorTemplate -suppress "transparency";

        editorTemplate -label "Texture Apply Mode:" -addControl "TextureApplyMode";
        
    editorTemplate -endLayout;

    //***************************************************************************
    editorTemplate -beginLayout "Geometry" -collapse true;
    
        editorTemplate -label "BiNormals & Tangents" -addControl "NBTMethod";

    editorTemplate -endLayout;

    //***************************************************************************
    editorTemplate -beginLayout "Vertex Colors" -collapse true;

       editorTemplate -label "Override Default Values" -addControl "VertexColorOverride" "AEaimVertexOverride";

       columnLayout -columnOffset "left" 100 -en false VertexLayout;

           editorTemplate -label "Source Mode:" -addControl "VertexColorSrcMode";

           editorTemplate -label "Light Mode:" -addControl "VertexColorLightMode";

       setParent ..; // columnLayout


    editorTemplate -endLayout;

    //***************************************************************************
    editorTemplate -beginLayout "Alpha Transparency" -collapse true;

        editorTemplate -label "Override Default Values" -addControl "TransparencyOverride" "AEaimTransparencyOverride";

        editorTemplate -beginLayout "Alpha Blending" -collapse true;

           editorTemplate -label "Use Alpha Blending:" -addControl "TransparencyUseAlphaBlending";

           editorTemplate -label "Source:" -addControl "TransparencySource";

           editorTemplate -label "Destination:" -addControl "TransparencyDestination";

        editorTemplate -endLayout;

        editorTemplate -beginLayout "Alpha Testing" -collapse true;

            editorTemplate -label "Use Alpha Testing" -addControl "TransparencyUseAlphaTesting";

            editorTemplate -label "No Sorter" -addControl "TransparencyNoTestingSorter";

            editorTemplate -label "Test Refrence:" -addControl "TransparencyTestReference";

            editorTemplate -label "Testing Mode:" -addControl "TransparencyTestingTestMode";

        editorTemplate -endLayout;

    editorTemplate -endLayout;

    //***************************************************************************
    editorTemplate -beginLayout "Textures" -collapse false;

        // ****** BASE MAP *****
        editorTemplate -beginLayout "Base Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "color" "Base Map Texture";
			editorTemplate -suppress "color";


            editorTemplate -label "Filter" -addControl "colorFilter" "AEaimBaseMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "colorMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "color";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Base Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "colorFlipBook" "AEaimBaseFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false BaseMapFlipBookLayout;
    
                    editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "colorFlipBookStartFrame" "Start Frame (image):";
		    editorTemplate -suppress "colorFlipBookStartFrame";
    
                    editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "colorFlipBookEndFrame" "End Frame (image):";
	            editorTemplate -suppress "colorFlipBookEndFrame";

                    editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "colorFlipBookFramesPerSecond" "Frames Per Second:";
                    editorTemplate -suppress "colorFlipBookFramesPerSecond";

                    editorTemplate -l  "Cycle Type:" -addControl "colorFlipBookCycleType";

                    editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "colorFlipBookStartTime" "Start Time (in Frames):";
		    editorTemplate -suppress "colorFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;

        // ****** DARK MAP *****
        editorTemplate -beginLayout "Dark Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "DarkMap" "";
	    editorTemplate -suppress "DarkMap";

            editorTemplate -label "Filter" -addControl "DarkMapFilter" "AEaimDarkMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "DarkMapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "DarkMap";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Dark Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "DarkMapFlipBook" "AEaimDarkFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false DarkMapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DarkMapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "DarkMapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DarkMapFlipBookEndFrame" "End Frame (image):" ;
			editorTemplate -suppress "DarkMapFlipBookEndFrame";
			
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DarkMapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "DarkMapFlipBookFramesPerSecond";
			
			editorTemplate -label "Cycle Type:" -addControl "DarkMapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DarkMapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "DarkMapFlipBookStartTime";
			
                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;

        // ****** Detail MAP *****
        editorTemplate -beginLayout "Detail Map" -collapse true;

		editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "DetailMap" "";
		editorTemplate -suppress "DetailMap";

            editorTemplate -label "Filter" -addControl "DetailMapFilter" "AEaimDetailMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "DetailMapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "DetailMap";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Detail Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "DetailMapFlipBook" "AEaimDetailFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false DetailMapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DetailMapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "DetailMapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace"  "DetailMapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "DetailMapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DetailMapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "DetailMapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "DetailMapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "DetailMapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "DetailMapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;


        // ****** DECAL 1 MAP *****
        editorTemplate -beginLayout "Decal 1 Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "Decal1Map" "";
	    editorTemplate -suppress "Decal1Map";

            editorTemplate -label "Filter" -addControl "Decal1MapFilter" "AEaimDecal1MaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "Decal1MapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "Decal1Map";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Decal 1 Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "Decal1MapFlipBook" "AEaimDecal1FlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false Decal1MapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal1MapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "Decal1MapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal1MapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "Decal1MapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal1MapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "Decal1MapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "Decal1MapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal1MapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "Decal1MapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;

        // ****** DECAL 2 MAP *****
        editorTemplate -beginLayout "Decal 2 Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "Decal2Map" "";
	    editorTemplate -suppress "Decal2Map";

            editorTemplate -label "Filter" -addControl "Decal2MapFilter" "AEaimDecal2MaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "Decal2MapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "Decal2Map";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Decal 2 Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "Decal2MapFlipBook" "AEaimDecal2FlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false Decal2MapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal2MapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "Decal2MapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal2MapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "Decal2MapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal2MapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "Decal2MapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "Decal2MapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "Decal2MapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "Decal2MapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;


        // ****** GLOW MAP *****
        editorTemplate -beginLayout "Glow Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "GlowMap" "";
	    editorTemplate -suppress "GlowMap";

            editorTemplate -label "Filter" -addControl "GlowMapFilter" "AEaimGlowMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "GlowMapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "GlowMap";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Glow Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "GlowMapFlipBook" "AEaimGlowFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false GlowMapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlowMapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "GlowMapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlowMapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "GlowMapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlowMapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "GlowMapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "GlowMapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlowMapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "GlowMapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;


        // ****** GLOSS MAP *****
        editorTemplate -beginLayout "Gloss Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "GlossMap" "";
	    editorTemplate -suppress "GlossMap";

            editorTemplate -label "Filter" -addControl "GlossMapFilter" "AEaimGlossMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "GlossMapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "GlossMap";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Gloss Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "GlossMapFlipBook" "AEaimGlossFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false GlossMapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlossMapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "GlossMapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlossMapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "GlossMapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlossMapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "GlossMapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "GlossMapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "GlossMapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "GlossMapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;


        // ****** BUMP MAP *****
        editorTemplate -beginLayout "Bump Map" -collapse true;

            editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "BumpMap" "";
	    editorTemplate -suppress "BumpMap";

            editorTemplate -label "Filter" -addControl "BumpMapFilter" "AEaimBumpMaxAnisotropyOverride";
            editorTemplate -label "Max Anisotropy" -addControl "BumpMapMaxAnisotropy";

            editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "BumpMap";

            editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapMat00" "Matrix 00";
	    editorTemplate -suppress "BumpMapMat00";
	    
            editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapMat01" "Matrix 01";
	    editorTemplate -suppress "BumpMapMat01";
	    
            editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapMat10" "Matrix 10";
	    editorTemplate -suppress "BumpMapMat10";
	    
            editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapMat11" "Matrix 11";
	    editorTemplate -suppress "BumpMapMat11";

                // ******* FLIP BOOK TEXTURE *******

            editorTemplate -beginLayout "Bump Map Flip Book" -collapse true;

                editorTemplate -label "Flip Book Texture" -addControl "BumpMapFlipBook" "AEaimBumpFlipBookOverride";
    
                columnLayout -columnOffset "left" 100 -en false BumpMapFlipBookLayout;
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapFlipBookStartFrame" "Start Frame (image):";
			editorTemplate -suppress "BumpMapFlipBookStartFrame";
    
			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapFlipBookEndFrame" "End Frame (image):";
			editorTemplate -suppress "BumpMapFlipBookEndFrame";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapFlipBookFramesPerSecond" "Frames Per Second:";
			editorTemplate -suppress "BumpMapFlipBookFramesPerSecond";

			editorTemplate -label "Cycle Type:" -addControl "BumpMapFlipBookCycleType";

			editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "BumpMapFlipBookStartTime" "Start Time (in Frames):";
			editorTemplate -suppress "BumpMapFlipBookStartTime";

                setParent ..; // columnLayout

            editorTemplate -endLayout;

        editorTemplate -endLayout;

    // ****** Normal MAP *****
    editorTemplate -beginLayout "Normal Map" -collapse true;

        editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "NormalMap" "";
	editorTemplate -suppress "NormalMap";

        editorTemplate -label "Filter" -addControl "NormalMapFilter" "AEaimNormalMaxAnisotropyOverride";
        editorTemplate -label "Max Anisotropy" -addControl "NormalMapMaxAnisotropy";

        editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "NormalMap";

            // ******* FLIP BOOK TEXTURE *******

        editorTemplate -beginLayout "Normal Map Flip Book" -collapse true;

            editorTemplate -label "Flip Book Texture" -addControl "NormalMapFlipBook" "AEaimNormalFlipBookOverride";

            columnLayout -columnOffset "left" 100 -en false NormalMapFlipBookLayout;

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "NormalMapFlipBookStartFrame" "Start Frame (image):";
		editorTemplate -suppress "NormalMapFlipBookStartFrame";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "NormalMapFlipBookEndFrame" "End Frame (image):";
		editorTemplate -suppress "NormalMapFlipBookEndFrame";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "NormalMapFlipBookFramesPerSecond" "Frames Per Second:";
		editorTemplate -suppress "NormalMapFlipBookFramesPerSecond";

                editorTemplate -label "Cycle Type:" -addControl "NormalMapFlipBookCycleType";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "NormalMapFlipBookStartTime" "Start Time (in Frames):";
		editorTemplate -suppress "NormalMapFlipBookStartTime";

            setParent ..; // columnLayout

        editorTemplate -endLayout;

    editorTemplate -endLayout;

    // ****** Parallax MAP *****
    editorTemplate -beginLayout "Parallax Map" -collapse true;

        editorTemplate -callCustom "AENiMultiShaderMapButtonNew" "AENiMultiShaderMapButtonReplace" "ParallaxMap" "";
	editorTemplate -suppress "ParallaxMap";
        editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "ParallaxMapOffset" "Offset";
	editorTemplate -suppress "ParallaxMapOffset";
        editorTemplate -label "Filter" -addControl "ParallaxMapFilter" "AEaimParallaxMaxAnisotropyOverride";
        editorTemplate -label "Max Anisotropy" -addControl "ParallaxMapMaxAnisotropy";

        editorTemplate -callCustom AENiMultiShaderUVSetUI AENiMultiShaderUVSetUI "ParallaxMap";

            // ******* FLIP BOOK TEXTURE *******

        editorTemplate -beginLayout "Parallax Map Flip Book" -collapse true;

            editorTemplate -label "Flip Book Texture" -addControl "ParallaxMapFlipBook" "AEaimParallaxFlipBookOverride";

            columnLayout -columnOffset "left" 100 -en false ParallaxMapFlipBookLayout;

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "ParallaxMapFlipBookStartFrame" "Start Frame (image):";
		editorTemplate -suppress "ParallaxMapFlipBookStartFrame";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "ParallaxMapFlipBookEndFrame" "End Frame (image):";
		editorTemplate -suppress "ParallaxMapFlipBookEndFrame";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "ParallaxMapFlipBookFramesPerSecond" "Frames Per Second:";
		editorTemplate -suppress "ParallaxMapFlipBookFramesPerSecond";

                editorTemplate -label "Cycle Type:" -addControl "ParallaxMapFlipBookCycleType";

                editorTemplate -callCustom "AENiMultiShaderControlNoMapNew" "AENiMultiShaderControlNoMapReplace" "ParallaxMapFlipBookStartTime" "Start Time (in Frames):";
		editorTemplate -suppress "ParallaxMapFlipBookStartTime";

            setParent ..; // columnLayout

        editorTemplate -endLayout;

    editorTemplate -endLayout;


    editorTemplate -endLayout;


    //***************************************************************************
    editorTemplate -beginLayout "Gamebryo Shader" -collapse false -bn AENiMultiShaderPixelShaderLayout;

        editorTemplate -callCustom AENiMultiShaderCreatePixelShaderNames AENiMultiShaderCreatePixelShaderNames "PixelShaderID";

        MyImmerseCreatePixelShaderUI($nodeName);

    editorTemplate -endLayout -en;

    // Create an "Extras" section and also add controls for any
    // attributes we have not explicitly mentioned.
    editorTemplate -addExtraControls;

    editorTemplate -endScrollLayout;

    // Tell the attribute editor not to display the attributes we
    // don't care about.
   
    editorTemplate -suppress "caching";
    editorTemplate -suppress "nodeState";
    editorTemplate -suppress "TextureApplyMode";

    editorTemplate -suppress "VertexColorOverride";
    editorTemplate -suppress "VertexColorSrcMode";
    editorTemplate -suppress "VertexColorLightMode";

    editorTemplate -suppress "TransparencyOverride";
    editorTemplate -suppress "TransparencySource";
    editorTemplate -suppress "TransparencyDestination";

    editorTemplate -suppress "colorL";
    editorTemplate -suppress "colorK";
    editorTemplate -suppress "colorFilter";
    editorTemplate -suppress "colorTempUVSet";

    editorTemplate -suppress "DarkMapL";
    editorTemplate -suppress "DarkMapK";
    editorTemplate -suppress "DarkMapFilter";
    editorTemplate -suppress "DarkMapTempUVSet";

    editorTemplate -suppress "DetailMapL";
    editorTemplate -suppress "DetailMapK";
    editorTemplate -suppress "DetailMapFilter";
    editorTemplate -suppress "DetailMapTempUVSet";

    editorTemplate -suppress "Decal1MapL";
    editorTemplate -suppress "Decal1MapK";
    editorTemplate -suppress "Decal1MapFilter";
    editorTemplate -suppress "Decal1MapTempUVSet";

    editorTemplate -suppress "Decal2MapL";
    editorTemplate -suppress "Decal2MapK";
    editorTemplate -suppress "Decal2MapFilter";
    editorTemplate -suppress "Decal2MapTempUVSet";

    editorTemplate -suppress "GlowMapL";
    editorTemplate -suppress "GlowMapK";
    editorTemplate -suppress "GlowMapFilter";
    editorTemplate -suppress "GlowMapTempUVSet";

    editorTemplate -suppress "GlossMapL";
    editorTemplate -suppress "GlossMapK";
    editorTemplate -suppress "GlossMapFilter";
    editorTemplate -suppress "GlossMapTempUVSet";

    editorTemplate -suppress "BumpMapL";
    editorTemplate -suppress "BumpMapK";
    editorTemplate -suppress "BumpMapFilter";
    editorTemplate -suppress "BumpMapLuminaScale";
    editorTemplate -suppress "BumpMapLuminaOffset";
    editorTemplate -suppress "BumpMapFilter";
    editorTemplate -suppress "BumpMapMat00";
    editorTemplate -suppress "BumpMapMat01";
    editorTemplate -suppress "BumpMapMat10";
    editorTemplate -suppress "BumpMapMat11";
    editorTemplate -suppress "BumpMapTempUVSet";
    
    editorTemplate -suppress "NormalMapFilter";
    editorTemplate -suppress "NormalMapTempUVSet";
    
    editorTemplate -suppress "ParallaxMapFilter";
    editorTemplate -suppress "ParallaxMapTempUVSet";
    editorTemplate -suppress "ParallaxMapOffset";

    editorTemplate -suppress "colorTransparency";
    editorTemplate -suppress "outTransparency";

    editorTemplate -suppress "PixelShaderName";
    editorTemplate -suppress "PixelShaderID";
    editorTemplate -suppress "PixelShaderImplementation";
    editorTemplate -suppress "PixelShaderExportImplementation";
    
    editorTemplate -suppress "transparency";

Cr8zyTracerOut("AENiMultiShaderTemplate", "", "");
}
//***************************************************************************
global proc AEMultiShaderGenericReplace( string $attrName )
{
Cr8zyTracerIn("AEMultiShaderGenericReplace", {"$attrName"}, {"" + $attrName});
    string $nodeName[];
    tokenize($attrName, ".", $nodeName);

    string $controlName = $nodeName[1] + "Grp";

   // Install the connection between the radioButtonGrp and the
   // actual L attribute
   connectControl $controlName $attrName;

    intSliderGrp -e -en false $controlName;

Cr8zyTracerOut("AEMultiShaderGenericReplace", "", "");
}
//***************************************************************************
global proc AEaimMaterialAlphaOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimMaterialAlphaOverride", {"$nodeName"}, {"" + $nodeName});
// Read in the Transparency attributes
    float $rgbValues[] = `colorSliderGrp -q -rgbValue ("MaterialAlpha_Control")`;
   
	 
	
    $nodeAttr = $nodeName +".transparencyR";
	setAttr $nodeAttr $rgbValues[0];
    float $valueR = `getAttr $nodeAttr`;
	

	
   $nodeAttr = $nodeName +".transparencyG";
	setAttr $nodeAttr $rgbValues[1];
   float $valueG = `getAttr $nodeAttr`;

	

   $nodeAttr = $nodeName +".transparencyB";
	setAttr $nodeAttr $rgbValues[2];
    float $valueB = `getAttr $nodeAttr`;


	
// Set the Out Transparency Attributes
    $nodeAttr = $nodeName +".outTransparencyR";
    setAttr $nodeAttr $valueR;

    $nodeAttr = $nodeName +".outTransparencyG";
    setAttr $nodeAttr $valueG;

    $nodeAttr = $nodeName +".outTransparencyB";
    setAttr $nodeAttr $valueB;
Cr8zyTracerOut("AEaimMaterialAlphaOverride", "", "");
}
//***************************************************************************
global proc AEaimVertexOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimVertexOverride", {"$nodeName"}, {"" + $nodeName});
    $nodeAttr = $nodeName +".VertexColorOverride";
    int $value = `getAttr $nodeAttr`;

    if($value == 0)
    {
        editorTemplate -dimControl $nodeName "VertexColorSrcMode" true;
        editorTemplate -dimControl $nodeName "VertexColorLightMode" true;
    }
    else
    {
        editorTemplate -dimControl $nodeName "VertexColorSrcMode" false;
        editorTemplate -dimControl $nodeName "VertexColorLightMode" false;
    }
Cr8zyTracerOut("AEaimVertexOverride", "", "");
}
//***************************************************************************
global proc AEaimTransparencyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimTransparencyOverride", {"$nodeName"}, {"" + $nodeName});
    $nodeAttr = $nodeName +".TransparencyOverride";
    int $value = `getAttr $nodeAttr`;

    if($value == 0)
    {
        editorTemplate -dimControl $nodeName "TransparencyUseAlphaBlending" true;
        editorTemplate -dimControl $nodeName "TransparencySource" true;
        editorTemplate -dimControl $nodeName "TransparencyDestination" true;
        editorTemplate -dimControl $nodeName "TransparencyUseAlphaTesting" true;
        editorTemplate -dimControl $nodeName "TransparencyNoTestingSorter" true;
        editorTemplate -dimControl $nodeName "TransparencyTestReference" true;
        editorTemplate -dimControl $nodeName "TransparencyTestingTestMode" true;
    }
    else
    {
        editorTemplate -dimControl $nodeName "TransparencyUseAlphaBlending" false;
        editorTemplate -dimControl $nodeName "TransparencySource" false;
        editorTemplate -dimControl $nodeName "TransparencyDestination" false;
        editorTemplate -dimControl $nodeName "TransparencyUseAlphaTesting" false;
        editorTemplate -dimControl $nodeName "TransparencyNoTestingSorter" false;
        editorTemplate -dimControl $nodeName "TransparencyTestReference" false;
        editorTemplate -dimControl $nodeName "TransparencyTestingTestMode" false;
    }
Cr8zyTracerOut("AEaimTransparencyOverride", "", "");
}
//***************************************************************************
global proc AEaimFlipBookOverride(string $nodeName, string $mapName)
{
Cr8zyTracerIn("AEaimFlipBookOverride", {"$nodeName", "$mapName"}, {"" + $nodeName, "" + $mapName});
    $nodeAttr = $nodeName + "." + $mapName + "FlipBook";
    int $value = `getAttr $nodeAttr`;

    if($value == 0)
    {
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookStartFrame") true;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookEndFrame") true;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookFramesPerSecond") true;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookCycleType") true;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookStartTime") true;
    }
    else
    {
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookStartFrame") false;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookEndFrame") false;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookFramesPerSecond") false;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookCycleType") false;
        editorTemplate -dimControl $nodeName ($mapName + "FlipBookStartTime") false;
    }
Cr8zyTracerOut("AEaimFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimMaxAnisotropyOverride(string $nodeName, string $mapName)
{
Cr8zyTracerIn("AEaimMaxAnisotropyOverride", {"$nodeName", "$mapName"}, {"" + $nodeName, "" + $mapName});
	$nodeAttr = $nodeName + "." + $mapName + "Filter";
	int $value = `getAttr $nodeAttr`;
	if($value == 6)
    {
		editorTemplate -dimControl $nodeName ($mapName + "MaxAnisotropy") false;
    }
    else
    {
		editorTemplate -dimControl $nodeName ($mapName + "MaxAnisotropy") true;
    }
Cr8zyTracerOut("AEaimMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimBaseMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimBaseMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
	AEaimMaxAnisotropyOverride($nodeName, "color");
Cr8zyTracerOut("AEaimBaseMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimDarkMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDarkMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "DarkMap");
Cr8zyTracerOut("AEaimDarkMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimDetailMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDetailMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "DetailMap");
Cr8zyTracerOut("AEaimDetailMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimDecal1MaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDecal1MaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "Decal1Map");
Cr8zyTracerOut("AEaimDecal1MaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimDecal2MaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDecal2MaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "Decal2Map");
Cr8zyTracerOut("AEaimDecal2MaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimGlowMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimGlowMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "GlowMap");
Cr8zyTracerOut("AEaimGlowMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimGlossMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimGlossMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "GlossMap");
Cr8zyTracerOut("AEaimGlossMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimNormalMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimNormalMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "NormalMap");
Cr8zyTracerOut("AEaimNormalMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimParallaxMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimParallaxMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "ParallaxMap");
Cr8zyTracerOut("AEaimParallaxMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimBumpMaxAnisotropyOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimBumpMaxAnisotropyOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimMaxAnisotropyOverride($nodeName, "BumpMap");
Cr8zyTracerOut("AEaimBumpMaxAnisotropyOverride", "", "");
}
//***************************************************************************
global proc AEaimBaseFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimBaseFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "color");
Cr8zyTracerOut("AEaimBaseFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimDarkFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDarkFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "DarkMap");
Cr8zyTracerOut("AEaimDarkFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimDetailFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDetailFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "DetailMap");
Cr8zyTracerOut("AEaimDetailFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimDecal1FlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDecal1FlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "Decal1Map");
Cr8zyTracerOut("AEaimDecal1FlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimDecal2FlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimDecal2FlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "Decal2Map");
Cr8zyTracerOut("AEaimDecal2FlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimGlowFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimGlowFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "GlowMap");
Cr8zyTracerOut("AEaimGlowFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimGlossFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimGlossFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "GlossMap");
Cr8zyTracerOut("AEaimGlossFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimNormalFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimNormalFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "NormalMap");
Cr8zyTracerOut("AEaimNormalFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimParallaxFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimParallaxFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "ParallaxMap");
Cr8zyTracerOut("AEaimParallaxFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimBumpFlipBookOverride(string $nodeName)
{
Cr8zyTracerIn("AEaimBumpFlipBookOverride", {"$nodeName"}, {"" + $nodeName});
    AEaimFlipBookOverride($nodeName, "BumpMap");
Cr8zyTracerOut("AEaimBumpFlipBookOverride", "", "");
}
//***************************************************************************
global proc AEaimBaseMapOnlyInitializeByConnections(string $nodeName)
{
Cr8zyTracerIn("AEaimBaseMapOnlyInitializeByConnections", {"$nodeName"}, {"" + $nodeName});
    // Find if the base map has a texture
    string $sBaseAttributeName = $nodeName + ".color";
    string $sBaseNames[] = `listConnections $sBaseAttributeName`;
    string $nodeAttr = $nodeName +".BaseMapOnly";

    // Check there are results returned
    if(size($sBaseNames) != 1)
    {
        setAttr $nodeAttr false;
Cr8zyTracerOut("AEaimBaseMapOnlyInitializeByConnections", "", "");
        return;
    }

    string $sBaseName = $sBaseNames[0];

    // Find the Material we are connected to
    string $sMaterialInfoNames[] = `listConnections -t materialInfo $nodeName`;

    // Check there are results returned
    if(size($sMaterialInfoNames) == 0)
    {
        setAttr $nodeAttr false;
Cr8zyTracerOut("AEaimBaseMapOnlyInitializeByConnections", "", "");
        return;
    }

    string $sMaterialInfoName = $sMaterialInfoNames[0];


    // Setup the Messages we are going to change
    string $sMaterialAttributeName = $nodeName + ".message";
    string $sInfoAttributeName = $sMaterialInfoName + ".texture[0]";
    string $sBaseMessageAttribute = $sBaseName + ".message";

    // Is the correct connection already made
    if(`isConnected $sMaterialAttributeName $sInfoAttributeName` == 1)
        setAttr $nodeAttr false;
    else
        setAttr $nodeAttr true;    
}
//***************************************************************************
global proc AEaimBaseMapOnly(string $nodeName)
{
Cr8zyTracerIn("AEaimBaseMapOnly", {"$nodeName"}, {"" + $nodeName});

    // Find if the base map has a texture
    string $sBaseAttributeName = $nodeName + ".color";
    string $sBaseNames[] = `listConnections $sBaseAttributeName`;

    // Check there are results returned
    if(size($sBaseNames) != 1)
    {
Cr8zyTracerOut("AEaimBaseMapOnly", "", "");
        return;
    }

    string $sBaseName = $sBaseNames[0];

    // Find the Material we are connected to
    string $sMaterialInfoNames[] = `listConnections -t materialInfo $nodeName`;

    // Check there are results returned
    if(size($sMaterialInfoNames) == 0)
    {
Cr8zyTracerOut("AEaimBaseMapOnly", "", "");
        return;
    }

    string $sMaterialInfoName = $sMaterialInfoNames[0];

    // Setup the Messages we are going to change
    string $sMaterialAttributeName = $nodeName + ".message";
    string $sInfoAttributeName = $sMaterialInfoName + ".texture[0]";
    string $sBaseMessageAttribute = $sBaseName + ".message";

    // Read in the Base Map Only attributes
    $nodeAttr = $nodeName +".BaseMapOnly";
    int $iValue = `getAttr $nodeAttr`;

    // Gray out the Resolution
    editorTemplate -dimControl $nodeName "resolution" $iValue;

    if($iValue == 1)
    {
        //disconnectAttr NiMultiShader1.message materialInfo1.texture[0];
        //connectAttr file1.message materialInfo1.texture[0];

        // Is the correct connection already made
        if(`isConnected $sBaseMessageAttribute $sInfoAttributeName` == 1)
        {
Cr8zyTracerOut("AEaimBaseMapOnly", "", "");
            return;
        }
        
        // Remove the Old Connection if it exists
        if(`isConnected $sMaterialAttributeName $sInfoAttributeName` == 1)
        {
            disconnectAttr $sMaterialAttributeName $sInfoAttributeName;
        }

        connectAttr $sBaseMessageAttribute $sInfoAttributeName;
    }
    else
    {
        //disconnectAttr file1.message materialInfo1.texture[0];
        //connectAttr NiMultiShader1.message materialInfo1.texture[0];

        // Is the correct connection already made
        if(`isConnected $sMaterialAttributeName $sInfoAttributeName` == 1)
        {
Cr8zyTracerOut("AEaimBaseMapOnly", "", "");
            return;
        }

        // Remove the Old Connection if it exists
        if(`isConnected $sBaseMessageAttribute $sInfoAttributeName` == 1)
        {
            disconnectAttr $sBaseMessageAttribute $sInfoAttributeName;
        }

        connectAttr $sMaterialAttributeName $sInfoAttributeName;
    }
}
//***************************************************************************
global proc AEaimTemporaryDisableUnfinishedFeatures(string $nodeName)
{
Cr8zyTracerIn("AEaimTemporaryDisableUnfinishedFeatures", {"$nodeName"}, {"" + $nodeName});
    editorTemplate -suppress "colorL";
    editorTemplate -suppress "colorK";
    editorTemplate -suppress "colorFilter";
    editorTemplate -suppress "colorTransparencyR";
    editorTemplate -suppress "colorTransparencyG";
    editorTemplate -suppress "colorTransparencyB";
    editorTemplate -suppress "colorTransparency";
    editorTemplate -suppress "DarkMapL";
    editorTemplate -suppress "DarkMapK";
    editorTemplate -suppress "DarkMapFilter";
    editorTemplate -suppress "DetailMapL";
    editorTemplate -suppress "DetailMapK";
    editorTemplate -suppress "DetailMapFilter";
    editorTemplate -suppress "Decal1MapL";
    editorTemplate -suppress "Decal1MapK";
    editorTemplate -suppress "Decal1MapFilter";
    editorTemplate -suppress "Decal2MapL";
    editorTemplate -suppress "Decal2MapK";
    editorTemplate -suppress "Decal2MapFilter";
    editorTemplate -suppress "GlowMapL";
    editorTemplate -suppress "GlowMapK";
    editorTemplate -suppress "GlowMapFilter";
    editorTemplate -suppress "GlossMapL";
    editorTemplate -suppress "GlossMapK";
    editorTemplate -suppress "GlossMapFilter";
    editorTemplate -suppress "BumpMapR";
    editorTemplate -suppress "BumpMapG";
    editorTemplate -suppress "BumpMapB";
    editorTemplate -suppress "BumpMap";
    editorTemplate -suppress "BumpMapL";
    editorTemplate -suppress "BumpMapK";
    editorTemplate -suppress "BumpMapFilter";
    editorTemplate -suppress "BumpMapMat00";
    editorTemplate -suppress "BumpMapMat01";
    editorTemplate -suppress "BumpMapMat10";
    editorTemplate -suppress "BumpMapMat11";
    editorTemplate -suppress "BumpMapLuminaScale";
    editorTemplate -suppress "BumpMapLuminaOffset";
    editorTemplate -suppress "NormalMapFilter";
    editorTemplate -suppress "ParallaxMapFilter";
    editorTemplate -suppress "ParallaxMapOffset";
    editorTemplate -suppress "MaterialDiffuseR";
    editorTemplate -suppress "MaterialDiffuseG";
    editorTemplate -suppress "MaterialDiffuseB";
    editorTemplate -suppress "MaterialDiffuse";
    editorTemplate -suppress "MaterialSpecularR";
    editorTemplate -suppress "MaterialSpecularG";
    editorTemplate -suppress "MaterialSpecularB";
    editorTemplate -suppress "MaterialSpecular";
    editorTemplate -suppress "MaterialAmbientR";
    editorTemplate -suppress "MaterialAmbientG";
    editorTemplate -suppress "MaterialAmbientB";
    editorTemplate -suppress "MaterialAmbient";
    editorTemplate -suppress "MaterialEmittanceR";
    editorTemplate -suppress "MaterialEmittanceG";
    editorTemplate -suppress "MaterialEmittanceB";
    editorTemplate -suppress "MaterialEmittance";
    editorTemplate -suppress "MaterialShineness";
    editorTemplate -suppress "MaterialAlpha";
    editorTemplate -suppress "Shading";
    editorTemplate -suppress "VertexColorOverride";
    editorTemplate -suppress "VertexColorSrcMode";
    editorTemplate -suppress "VertexColorLightMode";
    editorTemplate -suppress "TextureApplyMode";
    editorTemplate -suppress "TransparencyOverride";
    editorTemplate -suppress "TransparencyUseAlphaBlending";
    editorTemplate -suppress "TransparencySource";
    editorTemplate -suppress "TransparencyDestination";
    editorTemplate -suppress "TransparencyUseAlphaTesting";
    editorTemplate -suppress "TransparencyNoTestingSorter";
    editorTemplate -suppress "TransparencyTestReference";
    editorTemplate -suppress "TransparencyTestingTestMode";
    editorTemplate -suppress "outTransparency";
    editorTemplate -suppress "BaseMapOnly";
Cr8zyTracerOut("AEaimTemporaryDisableUnfinishedFeatures", "", "");
}


//***************************************************************************
global proc string MyImmerseNiMultiShaderGetSelectedShape()
{
Cr8zyTracerIn("MyImmerseNiMultiShaderGetSelectedShape", {}, {});
    // Check for a single shape
    string $szShapes[] = `ls -sl -typ shape`;

    if (size($szShapes) > 1)
        return "";   // To Many Shapes

    if (size($szShapes) == 0)
    {

        // Check for a single tranform
        string $szTransforms[] = `ls -sl -typ transform`;

        // We only work on a single tranform
        if(size($szTransforms) != 1)
            return "";   // Only works on single tranform

        // Get the Transform shape
        $szShapes = `listRelatives -s -ni $szTransforms[0]`;

        // WE only work on a single shape
        if (size($szShapes) != 1)
            return "";   // No Transform with a shape selected

    }

    //  print("MyImmerseNiMultiShaderGetSelectedShape " + $szShapes[0] + "\n");
Cr8zyTracerOut("MyImmerseNiMultiShaderGetSelectedShape", "", "");
    return $szShapes[0];
}
//***************************************************************************
global proc int MyImmerseNiMultiShaderGetUVSet(string $szSets[])
{
Cr8zyTracerIn("MyImmerseNiMultiShaderGetUVSet", {"$szSets"}, {"" + stringArrayToString($szSets, " ")});
    
    string $szShape = MyImmerseNiMultiShaderGetSelectedShape();

    if($szShape == "")
    {
Cr8zyTracerOut("MyImmerseNiMultiShaderGetUVSet", "$szShape empty earlyOut", "" + 1);
        return 1;
    }

    if(`attributeExists "uvSet" $szShape` == 0)
    {
Cr8zyTracerOut("MyImmerseNiMultiShaderGetUVSet", "uvSet doesn't exist early out", "" + 1);
        return 1;
    }

    string $szAttribute = $szShape + ".uvSet";

    // Get the Number of UVSets
    int $iNumUVSets = `getAttr -size $szAttribute`;

    int $iLoop;

    for ( $iLoop = 0; $iLoop < $iNumUVSets; $iLoop++ )
    {
        $szAttribute = $szShape + ".uvSet[" + $iLoop + "].uvSetName";

        string $szUVSetName = `getAttr $szAttribute`;

        //  print ($szUVSetName + "\n");

        $szSets[$iLoop] = $szUVSetName;
    }

Cr8zyTracerOut("MyImmerseNiMultiShaderGetUVSet", "return", "" + 0);
    return 0;
}
//***************************************************************************
global proc int AEMultiGetConnectedTextureSet(string $szMapName)
{
Cr8zyTracerIn("AEMultiGetConnectedTextureSet", {"$szMapName"}, {"" + $szMapName});

    // Check for a single shape
    string $szShapesList[] = `ls -sl -typ shape`;

    if (size($szShapesList) > 1)
        return 1;   // To Many Shapes

    if (size($szShapesList) == 0)
    {

        // Check for a single tranform
        string $szTransforms[] = `ls -sl -typ transform`;

        // We only work on a single tranform
        if(size($szTransforms) != 1)
            return 2;   // Only works on single tranform

        // Get the Transform shape
        $szShapesList = `listRelatives -s $szTransforms[0]`;

        // WE only work on a single shape
        if (size($szShapesList) != 1)
            return 3;   // No Transform with a shape selected

    }

    string $szShape = $szShapesList[0];

    //  print ("Map " + $szMapName + "\n");
    //  print ("shape " + $szShape + "\n");

    // Get the connected texture
    string $szConnections[] = `listConnections $szMapName`;
    //  print ($szConnections[0] + "\n");

    if (size($szConnections) != 1)
    {
Cr8zyTracerOut("AEMultiGetConnectedTextureSet", "", "");
        return -1;
    }

    string $szUVSet[] = `uvLink -q -t $szConnections[0] -qo $szShape`;
    //  print ($szUVSet[0] + "\n");

Cr8zyTracerOut("AEMultiGetConnectedTextureSet", "", "");
    return 0;
}
//***************************************************************************
global proc string AEMyImmerseFindAttributeName(string $szName)
{
Cr8zyTracerIn("AEMyImmerseFindAttributeName", {"$szName"}, {"" + $szName});
    string $szAttribute;
    
    // Would have used match but it didn't work
    //

    // Scan the name looking for a . then return everything after it

    int $iLoop;
    for($iLoop = 1; $iLoop <= size($szName); $iLoop++)
    {
        if(substring($szName, $iLoop, $iLoop) == ".")
        {
            $szAttribute = substring($szName, $iLoop + 1, size($szName));
        }
    };

    //  print("Attribute " + $szAttribute + "\n");
Cr8zyTracerOut("AEMyImmerseFindAttributeName", "", "");
    return $szAttribute;
}
//***************************************************************************
global proc AEMultiRelinkTextureObjectUV(string $szMapName, string $szTempUVTag)
{
Cr8zyTracerIn("AEMultiRelinkTextureObjectUV", {"$szMapName", "$szTempUVTag"}, {"" + $szMapName, "" + $szTempUVTag});
    //  print ("Entering Relink\n");

    // Get the Map Name
    string $szMap = AEMyImmerseFindAttributeName($szMapName);
    //  print ("Map " + $szMap + "\n");
  
    // Get the Shape we are opperating on
    string $szShape = MyImmerseNiMultiShaderGetSelectedShape();
    if ($szShape == "")
    {
Cr8zyTracerOut("AEMultiRelinkTextureObjectUV", "", "");
        return;
    }

    //  print ("Shape " + $szShape + "\n");

    // Get the connected texture
    string $szConnections[] = `listConnections $szMapName`;
    //  print ($szConnections[0] + "\n");

    if (size($szConnections) != 1)
    {
Cr8zyTracerOut("AEMultiRelinkTextureObjectUV", "", "");
        return;
    }

    string $szTexture = $szConnections[0];

    //  print ("Texture " + $szTexture + "\n");

    // Get the Currently selected UVSet
    string $szUVTemp;
    
    if($szTempUVTag == "")
        $szUVTemp = $szMapName + "TempUVSet";
    else
        $szUVTemp = $szTempUVTag;

    //  print ("TempUVSet " + $szUVTemp + "\n");

    int $iCurrentUVSet = `getAttr $szUVTemp`;
    //  print ("Current UVSet " + $iCurrentUVSet + "\n");


    // Relink the UV Coordinates
    string $szShapeUVMap = $szShape + ".uvSet[" + $iCurrentUVSet + "].uvSetName";
    //  print ("ShapeUVMap " + $szShapeUVMap + "\n");

    uvLink -make -uvSet $szShapeUVMap -texture $szTexture;

    //  print ("Exiting Relink\n");
}


//***************************************************************************
global proc AENiMultiShaderUVSetUI(string $szMapName)
{
Cr8zyTracerIn("AENiMultiShaderUVSetUI", {"$szMapName"}, {"" + $szMapName});

    string $szMenuName = AEMyImmerseFindAttributeName($szMapName) + "UVSet";
    // print("MenuName " + $szMenuName + "\n");


    if(`attrEnumOptionMenu -ex $szMenuName` == 1)
    {
        //  print ("BEFORE THE DELETE OF" + $szMenuName + "\n");
        deleteUI -control $szMenuName;
    }


    string $szSets[];

    if(MyImmerseNiMultiShaderGetUVSet($szSets) > 0)
    {
        attrEnumOptionMenu 
            -label "                               UV Set" 
            -ei 0 "Select ONLY 1 shape to modify UVs"
            -en false
            $szMenuName;
    }
    else
    {
        string $szCommand = "attrEnumOptionMenu -label \"                               UV Set\" ";

        int $iLoop;
        for ($iLoop = 0; $iLoop < size($szSets); $iLoop++)
        {
            if ($szSets[$iLoop] != "")
            {
                $szCommand = $szCommand + " -ei " + $iLoop + " " + $szSets[$iLoop];
            }
        }

        $szCommand = $szCommand + " -at " + $szMapName + "TempUVSet";
        $szCommand = $szCommand + " " + $szMenuName;

        //  print ($szCommand + "\n");
        string $szReturn = `eval $szCommand`;
        
        // Find which UVSet Should be selected
        int $iUVSet = AEMultiGetConnectedTextureSet($szMapName);

        if($iUVSet < 0)
        {
Cr8zyTracerOut("AENiMultiShaderUVSetUI", "", "");
            return;
        }

        scriptJob 
            -p $szReturn
            -rp
            -ac ($szMapName + "TempUVSet") ("AEMultiRelinkTextureObjectUV(\"" + $szMapName + "\", \"\")");
    }

}
//***************************************************************************
global proc AENiMultiShaderCreatePixelShaderImplementations( string $szNode, string $szNodeName )
{
Cr8zyTracerIn("AENiMultiShaderCreatePixelShaderImplementations", {"$szNode", "$szNodeName"}, {"" + $szNode, "" + $szNodeName});
    // Get the Current Gamebryo Shader ID
    string $szPixelShaderName = $szNodeName;

    int $iPixelShaderID;
    if( catch( $iPixelShaderID = AENiMultiShaderMapShaderNameToID($szPixelShaderName) ) )
    {
        warning("Shader " + $szPixelShaderName + " not found. Defaulting to NONE.");
        $iPixelShaderID = 0;
    }

    // Create the Viewer Implementation
    string $szCommand = "attrEnumOptionMenu -label \"Viewer Implementation:\" ";

    int $iLoop;
    string $szShaders[] = MyImmerseGetPixelShaderImplementations($iPixelShaderID);

    $szCommand = $szCommand + " -ei 0 \"Best Available\"";

    for ($iLoop = 0; $iLoop < size($szShaders); $iLoop++)
    {   
        $szCommand = $szCommand + " -ei " + ($iLoop+1) + " \"" + $szShaders[$iLoop] + "\"";
    }

    $szCommand = $szCommand + " -at " + $szNode + ".PixelShaderImplementation";
    $szCommand = $szCommand + " AENiMultiShaderViewerImplementationName;";

    //  print ($szCommand + "\n");
    string $szViewerReturn = `eval $szCommand`;



    // Create the Export Implementation
    string $szCommand = "attrEnumOptionMenu -label \"Export Implementation:\" ";

    $szCommand = $szCommand + " -ei 0 \"Best Available\"";

    for ($iLoop = 0; $iLoop < size($szShaders); $iLoop++)
    {   
        $szCommand = $szCommand + " -ei " + ($iLoop+1) + " \"" + $szShaders[$iLoop] + "\"";
    }

    $szCommand = $szCommand + " -at " + $szNode + ".PixelShaderExportImplementation";
    $szCommand = $szCommand + " AENiMultiShaderExportImplementationName;";

    //  print ($szCommand + "\n");
    string $szExporterReturn = `eval $szCommand`;


    // Create the Implementation Description

    text -l "" AENiMultiShaderImplementationSpacer1;
    text -l "Implementation Description:" -al "left" -fn "boldLabelFont" AENiMultiShaderImplementationDescriptionTitle;
    
    rowLayout -nc 2 -cw2 30 350;
        text -l ""; 
        scrollField -ww true -nl 10 AENiMultiShaderImplementationDescription;
    setParent ..; // RowLayout

    text -l "" AENiMultiShaderImplementationSpacer2;

    // Set the Description
    AEMultiRelinkImplementationDescription($szNode, 1);

    // Create the Script Jobs to tie the interface togeather
    scriptJob 
        -p $szViewerReturn
        -rp
        -ac ($szNode + ".PixelShaderImplementation") ("AEMultiRelinkImplementationDescription(\"" + $szNode + "\", 1 )");


    scriptJob 
        -p $szExporterReturn
        -rp
        -ac ($szNode + ".PixelShaderExportImplementation") ("AEMultiRelinkImplementationDescription(\"" + $szNode + "\", 0 )");

Cr8zyTracerOut("AENiMultiShaderCreatePixelShaderImplementations", "", "");
}
//***************************************************************************
global proc AENiMultiShaderCreatePixelShaderTextureUVs( string $szNode, string $szNodeName, string $szCurrentShaderName )
{
Cr8zyTracerIn("AENiMultiShaderCreatePixelShaderTextureUVs", {"$szNode", "$szNodeName", "$szCurrentShaderName"}, {"" + $szNode, "" + $szNodeName, "" + $szCurrentShaderName});

    // Create the Implementation Description

    text -l "" AENiMultiShaderTextureUVSpacer1;
    text -l "Texture UV Sets:" -al "left" -fn "boldLabelFont" AENiMultiShaderTextureUVTitle;


    // Get the Current Gamebryo Shader ID
    int $iPixelShaderID = `getAttr $szNodeName`;

   
    string $szTextureAttributeNames[] = MyImmersePixelShaderGetTextureAttributes($szCurrentShaderName);


    string $szSets[];

    int $iUVFailed = MyImmerseNiMultiShaderGetUVSet($szSets);

        // Get the Available UVSets
    
    print("$szSets are ...");
    print($szSets);
    print("\n");


    // Create the UV Set Elements
    
    int $iLoop = 0;

    for($iLoop = 0; $iLoop < size($szTextureAttributeNames); $iLoop++)
    {
         print ("Att Name " + $szTextureAttributeNames[$iLoop] + "\n");

        if( $iUVFailed == 1)
        {
            attrEnumOptionMenu 
                -label ($szTextureAttributeNames[$iLoop] + " UVSet")
                -en false
                ("AEMultiShader" + $szTextureAttributeNames[$iLoop]);
        }
        else
        {
            string $szMapAttributeName = "Ni_PixelShaderAttribute_" + $szCurrentShaderName + "_" + $szTextureAttributeNames[$iLoop];
            string $szMapName = $szNode + "." + $szMapAttributeName;
            
            print("$szMapName = " + $szMapName);

            print("$szNodeName = " + $szNodeName);

            print("$szNode = " + $szNode);

            // Verify the attribute exists. If the shader variables have changed then this attribute might not exist.
            if(`attributeExists ($szMapAttributeName + "_TempUVSet") $szNode` == 1)
            {
                string $szCommand = "attrEnumOptionMenu -label \"       " + $szTextureAttributeNames[$iLoop] + " UVSet \" ";

                int $iCommandLoop;

                for ($iCommandLoop = 0; $iCommandLoop < size($szSets); $iCommandLoop++)
                {   
                    $szCommand = $szCommand + " -ei " + $iCommandLoop + " \"" + $szSets[$iCommandLoop] + "\"";
                }

                $szCommand = $szCommand + " -at " + $szMapName + "_TempUVSet";
                $szCommand = $szCommand + (" AEMultiShader" + $szTextureAttributeNames[$iLoop] + ";");

                print ("stupid Eval command");
                print ($szCommand + "2\n");
                string $szReturn = `eval $szCommand`;

                scriptJob 
                    -p $szReturn
                    -rp
                    -ac ($szMapName + "_TempUVSet") ("AEMultiRelinkTextureObjectUV(\"" + $szMapName + "_Texture" + "\", \"" + $szMapName + "_TempUVSet\")");
                
            }

        }
    }

/*
    // Set the Description
    AEMultiRelinkImplementationDescription($szNode, 1);

    // Create the Script Jobs to tie the interface togeather
    scriptJob 
        -p $szViewerReturn
        -rp
        -ac ($szNode + ".PixelShaderImplementation") ("AEMultiRelinkImplementationDescription(\"" + $szNode + "\", 1 )");


    scriptJob 
        -p $szExporterReturn
        -rp
        -ac ($szNode + ".PixelShaderExportImplementation") ("AEMultiRelinkImplementationDescription(\"" + $szNode + "\", 0 )");
*/
Cr8zyTracerOut("AENiMultiShaderCreatePixelShaderTextureUVs", "", "");
}
//***************************************************************************
global proc AENiMultiShaderCreatePixelShaderNames( string $nodeName )
{
Cr8zyTracerIn("AENiMultiShaderCreatePixelShaderNames", {"$nodeName"}, {"" + $nodeName});
//  print ("AENiMultiShaderCreatePixelShaderNames\n");


//        print ("BEFORE THE DELETE OF AENiMultiShaderPixelShaderName\n");
// 
//  MAKE SURE THE UI DOESN"T EXIST BEFORE WE TRY AND CREATE IT
//
    if (`columnLayout -ex AENiMultiShaderDeletionLayout`)
        deleteUI -lay AENiMultiShaderDeletionLayout;


    // Get the Gamebryo Shader Name for this object
    // Strip off the Attribute Name
    string $szNode = `substitute ".PixelShaderID" $nodeName ""`;
    string $szCurrentShaderName = `getAttr ($szNode + ".PixelShaderName")`;

    int $realId = AENiMultiShaderMapShaderNameToID($szCurrentShaderName);

    setAttr $nodeName $realId;

    columnLayout AENiMultiShaderDeletionLayout;
    
    string $szCommand = "attrEnumOptionMenu -label \"Available Gamebryo Shaders:\" ";

    int $iLoop;
    string $szShaders[] = MyImmerseGetPixelShaderNames();

    $szCommand = $szCommand + " -ei 0 \"NONE\"";

    for ($iLoop = 0; $iLoop < size($szShaders); $iLoop++)
    {   
        $szCommand = $szCommand + " -ei " + ($iLoop+1) + " \"" + $szShaders[$iLoop] + "\"";
    }

    $szCommand = $szCommand + " -at " + $nodeName;
    $szCommand = $szCommand + " AENiMultiShaderPixelShaderName;";

    //print( $szCommand +"\n");

    //  print ($szCommand + "\n");
    string $szReturn = `eval $szCommand`;



    //print($szReturn + "\n");

    text -l "" AENiMultiShaderPixelShaderSpacer1;
    
    rowLayout -nc 2 -cw2 30 200;
        text -l ""; 
        text -l "Gamebryo Shader Description:" -al "left" -fn "boldLabelFont" AENiMultiShaderPixelShaderDescriptionTitle;
    setParent ..; // RowLayout
    
    rowLayout -nc 2 -cw2 30 350;
        text -l ""; 
        scrollField -ww true -nl 10 AENiMultiShaderPixelShaderDescription;
    setParent ..; // RowLayout
    
    text -l "" AENiMultiShaderPixelShaderSpacer2;

    // Set the Description
    AEMultiRelinkPixelShaderDescription($nodeName);

    scriptJob 
        -p $szReturn
        -rp
        -ac $nodeName ("AEMultiRelinkPixelShaderDescription(\"" + $nodeName + "\")");


    rowLayout -nc 2 AEMultiShaderPixelShaderButtonLayout;
            
        text -label "" AENiMultiShaderPixelShaderSpacer3;

        button 
            -label "Select Gamebryo Shader" 
            -c ("AEMultiRelinkPixelShaderName(\"" + $nodeName + "\")")
            AEMultiResetPixelShaderButton;

    setParent ..; // RowLayout

    text -l "" AENiMultiShaderPixelShaderSpacer4;

    // Check to see if all of the attributes are correct
    int $iInvalidShaderName = MyImmersePixelShaderVerifyShaderName($szNode, 1);
    int $iInvalidAttributes = MyImmersePixelShaderVerifyAttributes($szNode, 1);


    columnLayout -adj true AENiMultiShaderPixelShaderColumnLayout;

        rowLayout -nc 2 AEMultiShaderPixelShaderNameLayout;
           
            text -l "Current Shader:" -al "left" -fn "boldLabelFont" AENiMultiShaderPixelCurrentTitle;

            if($szCurrentShaderName == "")
            {
                text -l "NONE" -al "left"  AENiMultiShaderPixelCurrentName;
            }
            else if($iInvalidAttributes == 1)
            {
                text -l ($szCurrentShaderName + "(Error::Invalid Arguments)") -al "left"  AENiMultiShaderPixelCurrentName;
            }
            else if($iInvalidShaderName == 1)
            {
                text -l ($szCurrentShaderName + "(Error::Gamebryo Shader Not Found)") -al "left"  AENiMultiShaderPixelCurrentName;
            }
            else
            {
                text -l $szCurrentShaderName -al "left"  AENiMultiShaderPixelCurrentName;
            }

        setParent ..; // RowLayout


        // Create the Implementation Drop Down
        AENiMultiShaderCreatePixelShaderImplementations( $szNode, $szCurrentShaderName);

        // Create the Texture UV Sets
        AENiMultiShaderCreatePixelShaderTextureUVs( $szNode, $nodeName, $szCurrentShaderName);
   

    setParent ..; // Gamebryo Shader columnLayout

    text -l "" AENiMultiShaderPixelShaderSpacer5;


    rowLayout -nc 2 -vis $iInvalidAttributes AEMultiShaderPixelShaderRelinkButtonLayout;
            
        text -label "" AENiMultiShaderPixelShaderSpacer6;

        button
            -label "Relink Shader Attributes"
            -en $iInvalidAttributes
            -c ("AEMultiRelinkPixelShaderAttributes(\"" + $szNode + "\")")
            AEMultiReLinkPixelShaderAttributesButton;

    setParent ..; // RowLayout
    
    setParent ..; // olumnLayout 
Cr8zyTracerOut("AENiMultiShaderCreatePixelShaderNames", "", "");
}

//***************************************************************************
global proc AEMultiRelinkPixelShaderDescription(string $szNodeName)
{
Cr8zyTracerIn("AEMultiRelinkPixelShaderDescription", {"$szNodeName"}, {"" + $szNodeName});
//  print ("AEMultiRelinkPixelShaderDescription\n");

    // Create New Shader Options For This Object
    int $iPixelShaderID = `getAttr $szNodeName`;
//  print ("Shader ID " + $iPixelShaderID + "\n");

    // Check for No Shaders
    if(`optionVar -ex MyImmersePixelShaderData` == 0)
    {
        scrollField -e -tx "" AENiMultiShaderPixelShaderDescription;
Cr8zyTracerOut("AEMultiRelinkPixelShaderDescription", "", "");
        return;
    }

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;
    string $szShaderData[];

    $iPixelShaderID = $iPixelShaderID - 1;

    if(($iPixelShaderID < 0) || ($iPixelShaderID >= size($szShaders)))
    {
        scrollField -e -tx "" AENiMultiShaderPixelShaderDescription;
Cr8zyTracerOut("AEMultiRelinkPixelShaderDescription", "", "");
        return;
    }

    tokenize($szShaders[$iPixelShaderID], ";", $szShaderData);

    scrollField -e -tx $szShaderData[1] AENiMultiShaderPixelShaderDescription;
}
//***************************************************************************
global proc AEMultiRelinkImplementationDescription(string $szNode, int $iViewer)
{
Cr8zyTracerIn("AEMultiRelinkImplementationDescription", {"$szNode", "$iViewer"}, {"" + $szNode, "" + $iViewer});
//  print ("AEMultiRelinkImplementationDescription\n");

    // Create New Shader Options For This Object
    int $iPixelShaderID = `getAttr ($szNode + ".PixelShaderID")`;
//  print ("Shader ID " + $iPixelShaderID + "\n");

    // Check for No Shaders
    if(`optionVar -ex MyImmersePixelShaderData` == 0)
    {
        scrollField -e -tx "" AENiMultiShaderImplementationDescription;
Cr8zyTracerOut("AEMultiRelinkImplementationDescription", "", "");
        return;
    }

    int $iImplementation = 0;

    // Check to see if we are using the viewer implementation
    if($iViewer == 1)
    {
        $iImplementation = `getAttr ($szNode + ".PixelShaderImplementation")`;
    }
    else
    {
        $iImplementation = `getAttr ($szNode + ".PixelShaderExportImplementation")`;
    }

    string $szDescription;

    if($iImplementation > 0)
    {
        // The Interface for Implementations is 1 Based
        $szDescription = MyImmerseGetPixelShaderImplementationDescription($iPixelShaderID, $iImplementation - 1);
    }

    //print ($szDescription + "\n");

    scrollField -e -tx $szDescription AENiMultiShaderImplementationDescription;
}
//***************************************************************************
global proc AEMultiRelinkPixelShaderName(string $szNodeName)
{
Cr8zyTracerIn("AEMultiRelinkPixelShaderName", {"$szNodeName"}, {"" + $szNodeName});
//  print ("Enter:: AEMultiRelinkPixelShaderName\n");

    // Create New Shader Options For This Object
    int $iPixelShaderID = `getAttr $szNodeName`;

//  print ("Shader ID " + $iPixelShaderID + "\n");

    // Strip off the Attribute Name
    string $szNode = `substitute ".PixelShaderID" $szNodeName ""`;

    // Remove all of the old attributes
    MyImmerseRemovePixelShaderAttributes($szNode);

    string $szShaderName = MyImmerseGetPixelShaderName($iPixelShaderID);

    setAttr ($szNode + ".PixelShaderName") -type "string" $szShaderName;

    // Clear the Viewer Implementation
    setAttr ($szNode + ".PixelShaderImplementation") 0;

    // Clear the Export Implementation
    setAttr ($szNode + ".PixelShaderExportImplementation") 0;

    // Check for an invalid shader
    if($szShaderName == "")
    {
        text -e  -l "NONE" AENiMultiShaderPixelCurrentName;
    }
    else
    {
        text -e -l $szShaderName AENiMultiShaderPixelCurrentName;
    }
    
    MyImmerseCreatePixelShaderAttributes($szNode, $szShaderName);

    //print ("Exit:: AEMultiRelinkPixelShaderName\n");
Cr8zyTracerOut("AEMultiRelinkPixelShaderName", "", "");
}
//***************************************************************************
global proc string[] MyImmerseGetPixelShaderNames()
{
Cr8zyTracerIn("MyImmerseGetPixelShaderNames", {}, {});
    string $szShaderNames[];
    string $szShaderData[];

    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderNames", "", "");
        return $szShaderNames;
    }

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;

    int $iShaderLoop = 0;

    for($iShaderLoop = 0; $iShaderLoop < size($szShaders); $iShaderLoop++)
    {
        tokenize($szShaders[$iShaderLoop], ";", $szShaderData);

        // Name;Description;Implementations;Attributes
        $szShaderNames[$iShaderLoop] = $szShaderData[0];
    }

Cr8zyTracerOut("MyImmerseGetPixelShaderNames", "", "");
    //$szShaderNames = sort(szShaderData);

    return $szShaderNames;
}
//***************************************************************************
global proc string MyImmerseGetPixelShaderName(int $iPixelShaderID)
{
Cr8zyTracerIn("MyImmerseGetPixelShaderName", {"$iPixelShaderID"}, {"" + $iPixelShaderID});
    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderName", "", "");
        return "";
    }

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;
    string $szShaderData[];

    $iPixelShaderID = $iPixelShaderID - 1;

    if(($iPixelShaderID < 0) || ($iPixelShaderID >= size($szShaders)))
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderName", "", "");
        return "";
    }

    tokenize($szShaders[$iPixelShaderID], ";", $szShaderData);

Cr8zyTracerOut("MyImmerseGetPixelShaderName", "", "");
    return $szShaderData[0];
}
//***************************************************************************
global proc string MyImmerseGetPixelShaderEntry(string $szShaderName)
{
Cr8zyTracerIn("MyImmerseGetPixelShaderEntry", {"$szShaderName"}, {"" + $szShaderName});
    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderEntry", "", "");
        return "";
    }

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;
    string $szShaderData[];

    int $iShaderLoop = 0;

    for($iShaderLoop = 0; $iShaderLoop < size($szShaders); $iShaderLoop++)
    {
        tokenize($szShaders[$iShaderLoop], ";", $szShaderData);

        // Name;Description;Implementations;Attributes
        if($szShaderName == $szShaderData[0])
        {
Cr8zyTracerOut("MyImmerseGetPixelShaderEntry", "", "");
            return $szShaders[$iShaderLoop];
        }
    }

    // shader not found return ""
Cr8zyTracerOut("MyImmerseGetPixelShaderEntry", "", "");
    return "";
}

//***************************************************************************
global proc int AENiMultiShaderMapShaderNameToID(string $szShaderName)
{
Cr8zyTracerIn("AENiMultiShaderMapShaderNameToID", {"$szShaderName"}, {"" + $szShaderName});

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;
    string $szShaderData[];

    int $iShaderLoop = 0;

    for($iShaderLoop = 0; $iShaderLoop < size($szShaders); $iShaderLoop++)
    {
        tokenize($szShaders[$iShaderLoop], ";", $szShaderData);

        // Name;Description;Implementations;Attributes
        if($szShaderName == $szShaderData[0])
            break;
    }

    if($iShaderLoop == size($szShaders))
    {
        //it didn't find the shader
        warning("Shader " + $szShaderName + " not found");
    }
    
    // 1 based
Cr8zyTracerOut("AENiMultiShaderMapShaderNameToID", "", "");
    return $iShaderLoop + 1;
}

//***************************************************************************
global proc string[] MyImmerseGetPixelShaderImplementations(int $iPixelShaderID)
{
Cr8zyTracerIn("MyImmerseGetPixelShaderImplementations", {"$iPixelShaderID"}, {"" + $iPixelShaderID});
    string $szShaderImplementations[];
    string $szShaderData[];
    string $szImpNames[];

    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderImplementations", "", "");
        return $szImpNames;
    }

    if($iPixelShaderID == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderImplementations", "", "");
        return $szImpNames;
    }


    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;

    // Get the Shader Entry
    // Shader ID is 1 based
    tokenize($szShaders[$iPixelShaderID - 1], ";", $szShaderData);

    // print ($szShaderData[2] + "\n");

    // Get the Implementations
    // Num Implementations|Name0|Desc0|Name1|Desc1......
    tokenize($szShaderData[2], "|", $szShaderImplementations);

    int $iImpLoop = 0;
    int $iNumImp = $szShaderImplementations[0];

    for($iImpLoop = 0; $iImpLoop < $iNumImp; $iImpLoop++)
    {
        $szImpNames[$iImpLoop] = $szShaderImplementations[(($iImpLoop * 2) + 1)];
    }

Cr8zyTracerOut("MyImmerseGetPixelShaderImplementations", "", "");
    return $szImpNames;
}
//***************************************************************************
global proc string MyImmerseGetPixelShaderImplementationDescription(
        int $iPixelShaderID, int $iImplementation)
{
Cr8zyTracerIn("MyImmerseGetPixelShaderImplementationDescription", {"$iPixelShaderID", "$iImplementation"}, {"" + $iPixelShaderID, "" + $iImplementation});
    print ("MyImmerseGetPixelShaderImplementationDescription\n");

    string $szShaderImplementations[];
    string $szShaderData[];
    string $szDescription;

    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderImplementationDescription", "", "");
        return $szDescription;
    }

    if($iPixelShaderID == 0)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderImplementationDescription", "", "");
        return $szDescription;
    }


    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;

    // Get the Shader Entry
    // Shader ID is 1 based
    tokenize($szShaders[$iPixelShaderID - 1], ";", $szShaderData);

    // print ($szShaderData[2] + "\n");

    // Get the Implementations
    // Num Implementations|Name0|Desc0|Name1|Desc1......
    tokenize($szShaderData[2], "|", $szShaderImplementations);


    // Check for an Implementation beyond the range
    int $iNumImp = $szShaderImplementations[0];
    
    if($iNumImp < $iImplementation)
    {
Cr8zyTracerOut("MyImmerseGetPixelShaderImplementationDescription", "", "");
        return $szDescription;
    }

    $szDescription = ($szShaderImplementations[($iImplementation * 2) + 1] + ":: " + $szShaderImplementations[($iImplementation * 2) + 2]);

    print ($szDescription + "\n");

Cr8zyTracerOut("MyImmerseGetPixelShaderImplementationDescription", "", "");
    return $szDescription;
}

//***************************************************************************
global proc int MyImmersePixelShaderGetNumAttributes(string $szShaderEntry)
{
Cr8zyTracerIn("MyImmersePixelShaderGetNumAttributes", {"$szShaderEntry"}, {"" + $szShaderEntry});
    string $szShaderData[];

    // Name;Description;Implementations;Attributes
    tokenize($szShaderEntry, ";", $szShaderData);

    string $szAttributeData[];

    tokenize($szShaderData[3], "#", $szAttributeData);

    // NumAttributes#Attribute0#Attribute1#.....
    int $iNumAttributes = $szAttributeData[0];
Cr8zyTracerOut("MyImmersePixelShaderGetNumAttributes", "", "");
    return $iNumAttributes;
}
//***************************************************************************
global proc string MyImmersePixelShaderGetAttribute(string $szShaderEntry, int $iAttribute)
{
Cr8zyTracerIn("MyImmersePixelShaderGetAttribute", {"$szShaderEntry", "$iAttribute"}, {"" + $szShaderEntry, "" + $iAttribute});
    string $szShaderData[];

    // Name;Description;Implementations;Attributes
    tokenize($szShaderEntry, ";", $szShaderData);

    string $szAttributeData[];

    // NumAttributes#Attribute0#Attribute1#.....
    tokenize($szShaderData[3], "#", $szAttributeData);

Cr8zyTracerOut("MyImmersePixelShaderGetAttribute", "", "");
    return $szAttributeData[$iAttribute + 1];
}
//***************************************************************************
global proc string[] MyImmersePixelShaderGetTextureAttributes(string $szShaderName)
{
Cr8zyTracerIn("MyImmersePixelShaderGetTextureAttributes", {"$szShaderName"}, {"" + $szShaderName});
    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);
    string $szTextureAttributeNames[];

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
Cr8zyTracerOut("MyImmersePixelShaderGetTextureAttributes", "", "");
        return $szTextureAttributeNames;
    }

    int $iLoop = 0;
    int $iNumTextures = 0;
    int $iNumAttributes = MyImmersePixelShaderGetNumAttributes($szShaderEntry);


    for($iLoop = 0; $iLoop < $iNumAttributes; $iLoop++)
    {
        string $szAttribute = MyImmersePixelShaderGetAttribute($szShaderEntry, $iLoop);
        string $szAttributeData[];

        // NumAttributes#Attribute0#Attribute1#.....

        tokenize($szAttribute, "|", $szAttributeData);

        if( $szAttributeData[2] == "Texture" )
        {
            $szTextureAttributeNames[$iNumTextures] = $szAttributeData[0];

//            print ("TextureName ::" + $szTextureAttributeNames[$iNumTextures] + "\n");
            $iNumTextures = $iNumTextures + 1;
        }
    }

Cr8zyTracerOut("MyImmersePixelShaderGetTextureAttributes", "", "");
    return $szTextureAttributeNames;
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderAttributes(string  $szNodeName, string $szShaderName)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderAttributes", {"$szNodeName", "$szShaderName"}, {"" + $szNodeName, "" + $szShaderName});
    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);
    string $szShaderData[];

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributes", "", "");
        return;
    }

    int $iLoop = 0;
    int $iNumAttributes = MyImmersePixelShaderGetNumAttributes($szShaderEntry);

    for($iLoop = 0; $iLoop < $iNumAttributes; $iLoop++)
    {
        string $szAttribute = MyImmersePixelShaderGetAttribute($szShaderEntry, $iLoop);

        // Attribute = AttName|AttType|AttMin|AttMax|AttDefault
        MyImmerseCreatePixelShaderAttribute($szNodeName, $szShaderName, $szAttribute);      
    }
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderUI(string $szNodeName)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderUI", {"$szNodeName"}, {"" + $szNodeName});
    // Check for No Shaders
    if(`optionVar -ex "MyImmersePixelShaderData"` == 0)
    {
Cr8zyTracerOut("MyImmerseCreatePixelShaderUI", "", "");
        return;
    }

    string $szShaders[] = `optionVar -q "MyImmersePixelShaderData"`;
    string $szShaderData[];

    int $iShaderLoop = 0;

    for($iShaderLoop = 0; $iShaderLoop < size($szShaders); $iShaderLoop++)
    {
        tokenize($szShaders[$iShaderLoop], ";", $szShaderData);

        // Name;Description;Implementations;Attributes
        MyImmerseCreatePixelShaderAttributesUI($szNodeName, $szShaderData[0]);
    }
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderAttributesUI(string  $szNodeName, string $szShaderName)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderAttributesUI", {"$szNodeName", "$szShaderName"}, {"" + $szNodeName, "" + $szShaderName});
    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributesUI", "", "");
        return;
    }

    int $iLoop = 0;
    int $iNumAttributes = MyImmersePixelShaderGetNumAttributes($szShaderEntry);

    for($iLoop = 0; $iLoop < $iNumAttributes; $iLoop++)
    {
        string $szAttribute = MyImmersePixelShaderGetAttribute($szShaderEntry, $iLoop);

        MyImmerseCreatePixelShaderAttributeUI($szNodeName, $szShaderName, $szAttribute);
    }

}
//***************************************************************************
global proc MyImmerseCreatePixelShaderAttribute(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderAttribute", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max

    if($szAttributeData[2] == "String")
    {
        print("String " + $szAttributeName + "\n");

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            addAttr -ln $szAttributeName -dt "string" -k false $szNodeName;
            setAttr ($szNodeName + "." + $szAttributeName) -type "string" $szAttributeData[3];
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Boolean")
    {
        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            addAttr -ln $szAttributeName -at bool $szNodeName;

            int $iDefault = $szAttributeData[3];
            setAttr ($szNodeName + "." + $szAttributeName) $iDefault;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "UnsignedInt")
    {
        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            addAttr -ln $szAttributeName -at long $szNodeName;

            int $iDefault = $szAttributeData[3];
            setAttr ($szNodeName + "." + $szAttributeName) $iDefault;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Float")
    {
        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            // Get the Default Values
            float $fDefault = $szAttributeData[3];
            int $iRanged = $szAttributeData[4];

            if($iRanged == 1)
            {
                float $fMin = $szAttributeData[5];
                float $fMax = $szAttributeData[6];
                addAttr -ln $szAttributeName -at "float" -min $fMin -max $fMax -dv $fDefault $szNodeName;
            }
            else
                addAttr -ln $szAttributeName -at "float" -dv $fDefault $szNodeName;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point2")
    {
        // Get the Default Values

        float $fDefault1 = $szAttributeData[3];
        float $fDefault2 = $szAttributeData[4];
        int $iRanged = $szAttributeData[5];

        if($iRanged == 1)
        {

            float $fMin1 = $szAttributeData[6];
            float $fMin2 = $szAttributeData[7];
            float $fMax1 = $szAttributeData[8];
            float $fMax2 = $szAttributeData[9];

            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {   
                addAttr -ln ($szAttributeName + "_1") -at "float" -min $fMin1 -max $fMax1 -dv $fDefault1 $szNodeName;
            }

            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -min $fMin2 -max $fMax2 -dv $fDefault2 $szNodeName;
            }
        }
        else
        {
            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {   
                addAttr -ln ($szAttributeName + "_1") -at "float" -dv $fDefault1 $szNodeName;
            }

            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -dv $fDefault2 $szNodeName;
            }
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point3")
    {
        // Get the Default Values
        float $fDefault1 = $szAttributeData[3];
        float $fDefault2 = $szAttributeData[4];
        float $fDefault3 = $szAttributeData[5];
        int $iRanged = $szAttributeData[6];

        if($iRanged == 1)
        {
            float $fMin1 = $szAttributeData[7];
            float $fMin2 = $szAttributeData[8];
            float $fMin3 = $szAttributeData[9];
            float $fMax1 = $szAttributeData[10];
            float $fMax2 = $szAttributeData[11];
            float $fMax3 = $szAttributeData[12];
    
            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_1") -at "float" -min $fMin1 -max $fMax1 -dv $fDefault1 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -min $fMin2 -max $fMax2 -dv $fDefault2 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_3") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_3") -at "float" -min $fMin3 -max $fMax3 -dv $fDefault3 $szNodeName;
            }
        }
        else
        {
            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_1") -at "float" -dv $fDefault1 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -dv $fDefault2 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_3") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_3") -at "float" -dv $fDefault3 $szNodeName;
            }
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point4")
    {
        float $fDefault1 = $szAttributeData[3];
        float $fDefault2 = $szAttributeData[4];
        float $fDefault3 = $szAttributeData[5];
        float $fDefault4 = $szAttributeData[6];
        int $iRanged = $szAttributeData[7];

        if($iRanged == 1)
        {
            float $fMin1 = $szAttributeData[8];
            float $fMin2 = $szAttributeData[9];
            float $fMin3 = $szAttributeData[10];
            float $fMin4 = $szAttributeData[11];
            float $fMax1 = $szAttributeData[12];
            float $fMax2 = $szAttributeData[13];
            float $fMax3 = $szAttributeData[14];
            float $fMax4 = $szAttributeData[15];
    
            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_1") -at "float" -min $fMin1 -max $fMax1 -dv $fDefault1 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -min $fMin2 -max $fMax2 -dv $fDefault2 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_3") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_3") -at "float" -min $fMin3 -max $fMax3 -dv $fDefault3 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_4") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_4") -at "float" -min $fMin4 -max $fMax4 -dv $fDefault4 $szNodeName;
            }
        }
        else
        {
            if(`attributeExists ($szAttributeName + "_1") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_1") -at "float" -dv $fDefault1 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_2") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_2") -at "float" -dv $fDefault2 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_3") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_3") -at "float" -dv $fDefault3 $szNodeName;
            }
    
            if(`attributeExists ($szAttributeName + "_4") $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_4") -at "float" -dv $fDefault4 $szNodeName;
            }
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Matrix")
    {
        // Matrixes have no default min max or default falues so We use Identity as our default
        if(`attributeExists ($szAttributeName + "_00") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_00") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_01") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_01") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_02") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_02") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_10") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_10") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_11") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_11") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_12") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_12") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_20") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_20") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_21") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_21") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_22") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_22") -at "float" -dv 1.0 $szNodeName;
        }
    }
    else if($szAttributeData[2] == "Transform")
    {
        // Matrixes have no default min max or default falues so We use Identity as our default

        if(`attributeExists ($szAttributeName + "_00") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_00") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_01") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_01") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_02") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_02") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_03") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_03") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_10") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_10") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_11") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_11") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_12") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_12") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_13") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_13") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_20") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_20") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_21") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_21") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_22") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_22") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_23") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_23") -at "float" -dv 1.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_30") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_30") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_31") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_31") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_32") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_32") -at "float" -dv 0.0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_33") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_33") -at "float" -dv 1.0 $szNodeName;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Color")
    {
        float $fDefaultR = $szAttributeData[3];
        float $fDefaultG = $szAttributeData[4];
        float $fDefaultB = $szAttributeData[5];
        int $iRanged = $szAttributeData[6];
        float $fMinR = 0.0;
        float $fMinG = 0.0;
        float $fMinB = 0.0;
        float $fMaxR = 1.0;
        float $fMaxG = 1.0;
        float $fMaxB = 1.0;

        if($iRanged == 1)
        {
            $fMinR = $szAttributeData[7];
            $fMinG = $szAttributeData[8];
            $fMinB = $szAttributeData[9];
            $fMaxR = $szAttributeData[10];
            $fMaxG = $szAttributeData[11];
            $fMaxB = $szAttributeData[12];
        }

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            addAttr -ln $szAttributeName -nc 3 -at float3 -uac $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Red") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Red") -at "float" -min $fMinR -max $fMaxR -dv $fDefaultR -p $szAttributeName $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Green") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Green") -at "float" -min $fMinG -max $fMaxG -dv $fDefaultG -p $szAttributeName $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Blue") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Blue") -at "float" -min $fMinB -max $fMaxB -dv $fDefaultB -p $szAttributeName $szNodeName;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "ColorA")
    {
        float $fDefaultR = $szAttributeData[3];
        float $fDefaultG = $szAttributeData[4];
        float $fDefaultB = $szAttributeData[5];
        float $fDefaultA = $szAttributeData[6];
        int $iRanged = $szAttributeData[7];
        float $fMinR = 0.0;
        float $fMinG = 0.0;
        float $fMinB = 0.0;
        float $fMinA = 0.0;
        float $fMaxR = 1.0;
        float $fMaxG = 1.0;
        float $fMaxB = 1.0;
        float $fMaxA = 1.0;

        if($iRanged == 1)
        {
            $fMinR = $szAttributeData[8];
            $fMinG = $szAttributeData[9];
            $fMinB = $szAttributeData[10];
            $fMinA = $szAttributeData[11];
            $fMaxR = $szAttributeData[12];
            $fMaxG = $szAttributeData[13];
            $fMaxB = $szAttributeData[14];
            $fMaxA = $szAttributeData[15];
        }

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
            addAttr -ln $szAttributeName -nc 3 -at float3 -uac $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Red") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Red") -at "float" -min $fMinR -max $fMaxR -dv $fDefaultR -p $szAttributeName $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Green") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Green") -at "float" -min $fMinG -max $fMaxG -dv $fDefaultG -p $szAttributeName $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "Blue") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "Blue") -at "float" -min $fMinB -max $fMaxB -dv $fDefaultB -p $szAttributeName $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_Alpha") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_Alpha") -at "float" -min $fMinA -max $fMaxA -dv $fDefaultA $szNodeName;
        }

Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Texture")
    {
        int $iDefaultMap = $szAttributeData[3];

        if(`attributeExists ($szAttributeName + "_Texture") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_Texture") -nc 3 -at float3 -uac $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_TextureRed") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_TextureRed") -at "float" -min 0.0 -max 1.0 -dv 1.0 -p ($szAttributeName + "_Texture") $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_TextureGreen") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_TextureGreen") -at "float" -min 0.0 -max 1.0 -dv 1.0 -p ($szAttributeName + "_Texture") $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_TextureBlue") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_TextureBlue") -at "float" -min 0.0 -max 1.0 -dv 1.0 -p ($szAttributeName + "_Texture") $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_Filter") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_Filter") -at enum -enumName "Nearest:BILerp:Nearest MIP Nearest:BILerp MIP Nearest:Nearest MIPLerp:TriLerp" $szNodeName;
            setAttr ($szNodeName + "." + $szAttributeName + "_Filter") 5;
        }

        if(`attributeExists ($szAttributeName + "_TempUVSet") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_TempUVSet") -at enum -enumName "E0:E1:E2:E3:E4:E5:E6:E7:E8:E9:E10:E11:E12:E13:E14:E15" $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_FlipBook") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBook") -at bool -dv 0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_FlipBookStartFrame") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBookStartFrame") -at short -dv 0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_FlipBookEndFrame") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBookEndFrame") -at short -dv 0 $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_FlipBookFramesPerSecond") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBookFramesPerSecond") -at "float" -dv 25 $szNodeName;
        }
        
        if(`attributeExists ($szAttributeName + "_FlipBookStartTime") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBookStartTime") -at "float" -dv 0 $szNodeName;
        }
        
        if(`attributeExists ($szAttributeName + "_FlipBookCycleType") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_FlipBookCycleType") -at enum -enumName "Looping:Reverse:Clamped" $szNodeName;
        }

        if(`attributeExists ($szAttributeName + "_Map") $szNodeName` == 0)
        {
            addAttr -ln ($szAttributeName + "_Map") -at char -min 0 -max 32 -dv $iDefaultMap $szNodeName;
        }
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Float8")
    {
        int $iLoop;
        
        // Matrixes have no default min max or default falues so We use Identity as our default
        for ($iLoop = 0; $iLoop < 8; $iLoop++)
        {
            if(`attributeExists ($szAttributeName + "_" + $iLoop) $szNodeName` == 0)
            {
                $fDefault = 0.0;
                if (($iLoop ==0) || ($iLoop == 5))
                    $fDefault = 1.0;
                
                addAttr -ln ($szAttributeName + "_" + $iLoop) -at "float" -dv $fDefault $szNodeName;
            }
        }                
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    else if($szAttributeData[2] == "Float12")
    {
        int $iLoop;
        
        // Matrixes have no default min max or default falues so We use Identity as our default
        for ($iLoop = 0; $iLoop < 12; $iLoop++)
        {
            if(`attributeExists ($szAttributeName + "_" + $iLoop) $szNodeName` == 0)
            {
                $fDefault = 0.0;
                if (($iLoop ==0) || ($iLoop == 5) || ($iLoop = 10))
                    $fDefault = 1.0;
                
                addAttr -ln ($szAttributeName + "_" + $iLoop) -at "float" -dv $fDefault $szNodeName;
            }
        }                
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    
    
    // Check for an Array Type
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);
    
    if ($szArrayInfo[0] == "Array")
    {
        MyImmerseCreatePixelShaderArrayAttribute($szNodeName, $szShaderName, $szAttribute);
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttribute", "", "");
        return;
    }
    
    
    // Give a Warning because the attrribute wasn't handled
    warning ("Unknown Attribute Type:: Name=" + $szAttributeName + " Type=" + $szAttributeData[1]);

}
//***************************************************************************
global proc MyImmerseCreatePixelShaderFloatAttribute(string $szNodeName, 
    string $szExtraAttributeName, 
    string $szAttributeData[],
    int $iDefaultIdx, 
    int $iMinIdx, 
    int $iMaxIdx, 
    int $iRangedIdx)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderFloatAttribute", {"$szNodeName", "$szExtraAttributeName", "Cr8zyConvertIntArrayToString({0})", "$iDefaultIdx", "$iMinIdx", "$iMaxIdx", "$iRangedIdx"}, {"" + $szNodeName, "" + $szExtraAttributeName, "" + Cr8zyConvertIntArrayToString({0}), "" + $iDefaultIdx, "" + $iMinIdx, "" + $iMaxIdx, "" + $iRangedIdx});
    if(`attributeExists $szExtraAttributeName $szNodeName` == 0)
    {
        // Get the Default Values
        float $fDefault = $szAttributeData[$iDefaultIdx];
        int $iRanged = $szAttributeData[$iRangedIdx];

        if($iRanged == 1)
        {
            float $fMin = $szAttributeData[$iMinIdx];
            float $fMax = $szAttributeData[$iMaxIdx];
            addAttr -ln $szExtraAttributeName -at "float" -min $fMin -max $fMax -dv $fDefault $szNodeName;
        }
        else
            addAttr -ln $szExtraAttributeName -at "float" -dv $fDefault $szNodeName;
    }
Cr8zyTracerOut("MyImmerseCreatePixelShaderFloatAttribute", "", "");
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderColorAttribute(
    string $szNodeName, 
    string $szExtraAttributeName, 
    string $szParentExtraAttribute,
    string $szAttributeData[],
    int $iDefaultIdx, 
    int $iMinIdx, 
    int $iMaxIdx, 
    int $iRangedIdx)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderColorAttribute", {"$szNodeName", "$szExtraAttributeName", "$szParentExtraAttribute", "Cr8zyConvertIntArrayToString({0})", "$iDefaultIdx", "$iMinIdx", "$iMaxIdx", "$iRangedIdx"}, {"" + $szNodeName, "" + $szExtraAttributeName, "" + $szParentExtraAttribute, "" + Cr8zyConvertIntArrayToString({0}), "" + $iDefaultIdx, "" + $iMinIdx, "" + $iMaxIdx, "" + $iRangedIdx});
    if(`attributeExists $szExtraAttributeName $szNodeName` == 0)
    {
        // Get the Default Values
        float $fDefault = $szAttributeData[$iDefaultIdx];
        int $iRanged = $szAttributeData[$iRangedIdx];

        if($iRanged == 1)
        {
            float $fMin = $szAttributeData[$iMinIdx];
            float $fMax = $szAttributeData[$iMaxIdx];
            
            if ($szParentExtraAttribute != "")
                addAttr -ln $szExtraAttributeName -at "float" -min $fMin -max $fMax -dv $fDefault -p $szParentExtraAttribute $szNodeName;
            else                
                addAttr -ln $szExtraAttributeName -at "float" -min $fMin -max $fMax -dv $fDefault $szNodeName;
        }
        else
        {
            if ($szParentExtraAttribute != "")
                addAttr -ln $szExtraAttributeName -at "float" -min 0.0 -max 1.0 -dv $fDefault -p $szParentExtraAttribute $szNodeName;
            else                
                addAttr -ln $szExtraAttributeName -at "float" -min 0.0 -max 1.0 -dv $fDefault $szNodeName;
        }
    }
Cr8zyTracerOut("MyImmerseCreatePixelShaderColorAttribute", "", "");
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderArrayAttribute(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderArrayAttribute", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
    int $iLoop;
    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Array,type,#Elements|DefaultValue|IsRanged|Min|Max
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);

    
    string $szSubType = $szArrayInfo[1];
    int $iNumElements = $szArrayInfo[2];
    int $iDefaultBase = 3;
    int $iElementSize = 1;
    int $iRanged = 3 + ($iNumElements * $iElementSize);
    int $iMinBase = $iRanged + 1;
    int $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    string $szExtraAttributeName;
    
    if ($szSubType == "String")
    {
//      print("String " + $szAttributeName + "\n");
        print("Error String Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if($szSubType == "Boolean")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            $szExtraAttributeName = ($szAttributeName + "_" + $iLoop);
            if(`attributeExists $szExtraAttributeName $szNodeName` == 0)
            {
                addAttr -ln $szExtraAttributeName -at bool $szNodeName;

                int $iDefault = $szAttributeData[$iDefaultBase + $iLoop];
                setAttr ($szNodeName + "." + $szExtraAttributeName) $iDefault;
            }
        }
    }
    else if($szSubType == "UnsignedInt")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            $szExtraAttributeName = ($szAttributeName + "_" + $iLoop);
            if(`attributeExists $szExtraAttributeName $szNodeName` == 0)
            {
                int $iDefault = $szAttributeData[$iDefaultBase + $iLoop];
                
                addAttr -ln $szExtraAttributeName -at long -dv $iDefault $szNodeName;
            }
        }
    }
    else if ($szSubType == "Float")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop), 
                $szAttributeData,
                $iDefaultBase + $iLoop, 
                $iMinBase + $iLoop,
                $iMaxBase + $iLoop, 
                $iRanged);
        }
    }
    else if ($szSubType == "Point2")
    {
        $iElementSize = 2;
        $iRanged = 3 + ($iNumElements * $iElementSize);
        $iMinBase = $iRanged + 1;
        $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_1"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize), 
                $iMinBase + ($iLoop * $iElementSize),
                $iMaxBase + ($iLoop * $iElementSize), 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_2"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 1, 
                $iMinBase + ($iLoop * $iElementSize) + 1,
                $iMaxBase + ($iLoop * $iElementSize) + 1, 
                $iRanged);
        }
    }
    else if ($szSubType == "Point3")
    {
        $iElementSize = 3;
        $iRanged = 3 + ($iNumElements * $iElementSize);
        $iMinBase = $iRanged + 1;
        $iMaxBase = $iMinBase +($iNumElements * $iElementSize);
    
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_1"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize), 
                $iMinBase + ($iLoop * $iElementSize),
                $iMaxBase + ($iLoop * $iElementSize), 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_2"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 1, 
                $iMinBase + ($iLoop * $iElementSize) + 1,
                $iMaxBase + ($iLoop * $iElementSize) + 1, 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_3"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 2, 
                $iMinBase + ($iLoop * $iElementSize) + 2,
                $iMaxBase + ($iLoop * $iElementSize) + 2, 
                $iRanged);
        }
    }
    else if ($szSubType == "Point4")
    {
        //print("Point4 Attribute " + $szAttributeName + "\n");
        $iElementSize = 4;
        $iRanged = 3 + ($iNumElements * $iElementSize);
        $iMinBase = $iRanged + 1;
        $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_1"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize), 
                $iMinBase + ($iLoop * $iElementSize),
                $iMaxBase + ($iLoop * $iElementSize), 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_2"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 1, 
                $iMinBase + ($iLoop * $iElementSize) + 1,
                $iMaxBase + ($iLoop * $iElementSize) + 1, 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_3"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 2, 
                $iMinBase + ($iLoop * $iElementSize) + 2,
                $iMaxBase + ($iLoop * $iElementSize) + 2, 
                $iRanged);

            MyImmerseCreatePixelShaderFloatAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_4"), 
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 3, 
                $iMinBase + ($iLoop * $iElementSize) + 3,
                $iMaxBase + ($iLoop * $iElementSize) + 3, 
                $iRanged);
        }
    }
    else if ($szSubType == "Color")
    {
        $iElementSize = 3;
        $iRanged = 3 + ($iNumElements * $iElementSize);
        $iMinBase = $iRanged + 1;
        $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if(`attributeExists $szAttributeName $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_" + $iLoop) -nc 3 -at float3 -uac $szNodeName;
            }
        
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Red"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize), 
                $iMinBase + ($iLoop * $iElementSize),
                $iMaxBase + ($iLoop * $iElementSize), 
                $iRanged);
                
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Green"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 1, 
                $iMinBase + ($iLoop * $iElementSize) + 1,
                $iMaxBase + ($iLoop * $iElementSize) + 1, 
                $iRanged);
                
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Blue"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 2, 
                $iMinBase + ($iLoop * $iElementSize) + 2,
                $iMaxBase + ($iLoop * $iElementSize) + 2, 
                $iRanged);
        }
    }   
    else if ($szSubType == "ColorA")
    {
        $iElementSize = 4;
        $iRanged = 3 + ($iNumElements * $iElementSize);
        $iMinBase = $iRanged + 1;
        $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if(`attributeExists $szAttributeName $szNodeName` == 0)
            {
                addAttr -ln ($szAttributeName + "_" + $iLoop) -nc 3 -at float3 -uac $szNodeName;
            }
        
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Red"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize), 
                $iMinBase + ($iLoop * $iElementSize),
                $iMaxBase + ($iLoop * $iElementSize), 
                $iRanged);
                
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Green"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 1, 
                $iMinBase + ($iLoop * $iElementSize) + 1,
                $iMaxBase + ($iLoop * $iElementSize) + 1, 
                $iRanged);
                
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "Blue"), 
                ($szAttributeName + "_" + $iLoop),
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 2, 
                $iMinBase + ($iLoop * $iElementSize) + 2,
                $iMaxBase + ($iLoop * $iElementSize) + 2, 
                $iRanged);
                
            MyImmerseCreatePixelShaderColorAttribute($szNodeName, 
                ($szAttributeName + "_" + $iLoop + "_Alpha"), 
                "",
                $szAttributeData,
                $iDefaultBase + ($iLoop * $iElementSize) + 3, 
                $iMinBase + ($iLoop * $iElementSize) + 3,
                $iMaxBase + ($iLoop * $iElementSize) + 3, 
                $iRanged);
        }
    }   
    else if ($szSubType == "Matrix")
    {
        print("Error Matrix Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Texture")
    {
        print("Error Texture Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Float8")
    {
        print("Error Float8 Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Float12")
    {
        print("Error float12 Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Array")
    {
        print("Error Array of Arrays type Unsupported:: " + $szAttributeName + "\n");
    }
    else 
    {
        print ("MyImmerseCreatePixelShaderArrayAttribute:: Unknown Array Type:: Attribute" + $szAttributeName + " Type::" + $szSubType + "\n");
    }
    
Cr8zyTracerOut("MyImmerseCreatePixelShaderArrayAttribute", "", "");
}
//***************************************************************************
global proc MyImmerseRemovePixelShaderAttributes(string $szNodeName)
{
Cr8zyTracerIn("MyImmerseRemovePixelShaderAttributes", {"$szNodeName"}, {"" + $szNodeName});
    string $szAttributes[] = `listAttr -ud $szNodeName`;

    int $iLoop = 0;
    for($iLoop = 0; $iLoop < size($szAttributes); $iLoop++)
    {
        if(`gmatch $szAttributes[$iLoop] "Ni_PixelShaderAttribute_*"` == 1)
        {
            if(`attributeExists $szAttributes[$iLoop] $szNodeName` == 1)
            {
                catch (`deleteAttr -at $szAttributes[$iLoop] $szNodeName`);
            }
        }
    }
Cr8zyTracerOut("MyImmerseRemovePixelShaderAttributes", "", "");
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderAttributeUI(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderAttributeUI", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
//  print ("MyImmerseCreatePixelShaderAttributeUI\n");

    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];
    string $szAttributUIName = "MyImmersePixelShaderAttribute_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max

    if($szAttributeData[2] == "String")
    {
//      print ("String UI\n");

        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Boolean")
    {
//      print ("Boolean UI\n");

        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "UnsignedInt")
    {
//      print("UnsignedInt UI\n");
        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Float")
    {
//      print("float UI\n");

        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point2")
    {
        editorTemplate -label ($szAttributeData[0] + "_X") -adc ($szAttributeName + "_1");
        editorTemplate -label ($szAttributeData[0] + "_Y") -adc ($szAttributeName + "_2");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point3")
    {
        editorTemplate -label ($szAttributeData[0] + "_X") -adc ($szAttributeName + "_1");
        editorTemplate -label ($szAttributeData[0] + "_Y") -adc ($szAttributeName + "_2");
        editorTemplate -label ($szAttributeData[0] + "_Z") -adc ($szAttributeName + "_3");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Point4")
    {

        editorTemplate -label ($szAttributeData[0] + "_X") -adc ($szAttributeName + "_1");
        editorTemplate -label ($szAttributeData[0] + "_Y") -adc ($szAttributeName + "_2");
        editorTemplate -label ($szAttributeData[0] + "_Z") -adc ($szAttributeName + "_3");
        editorTemplate -label ($szAttributeData[0] + "_W") -adc ($szAttributeName + "_4");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Matrix")
    {
        editorTemplate -label ($szAttributeData[0] + "_00") -adc ($szAttributeName + "_00");
        editorTemplate -label ($szAttributeData[0] + "_01") -adc ($szAttributeName + "_01");
        editorTemplate -label ($szAttributeData[0] + "_02") -adc ($szAttributeName + "_02");

        editorTemplate -label ($szAttributeData[0] + "_10") -adc ($szAttributeName + "_10");
        editorTemplate -label ($szAttributeData[0] + "_11") -adc ($szAttributeName + "_11");
        editorTemplate -label ($szAttributeData[0] + "_12") -adc ($szAttributeName + "_12");

        editorTemplate -label ($szAttributeData[0] + "_20") -adc ($szAttributeName + "_20");
        editorTemplate -label ($szAttributeData[0] + "_21") -adc ($szAttributeName + "_21");
        editorTemplate -label ($szAttributeData[0] + "_22") -adc ($szAttributeName + "_22");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Transform")
    {
        editorTemplate -label ($szAttributeData[0] + "_00") -adc ($szAttributeName + "_00");
        editorTemplate -label ($szAttributeData[0] + "_01") -adc ($szAttributeName + "_01");
        editorTemplate -label ($szAttributeData[0] + "_02") -adc ($szAttributeName + "_02");
        editorTemplate -label ($szAttributeData[0] + "_03") -adc ($szAttributeName + "_03");

        editorTemplate -label ($szAttributeData[0] + "_10") -adc ($szAttributeName + "_10");
        editorTemplate -label ($szAttributeData[0] + "_11") -adc ($szAttributeName + "_11");
        editorTemplate -label ($szAttributeData[0] + "_12") -adc ($szAttributeName + "_12");
        editorTemplate -label ($szAttributeData[0] + "_13") -adc ($szAttributeName + "_13");

        editorTemplate -label ($szAttributeData[0] + "_20") -adc ($szAttributeName + "_20");
        editorTemplate -label ($szAttributeData[0] + "_21") -adc ($szAttributeName + "_21");
        editorTemplate -label ($szAttributeData[0] + "_22") -adc ($szAttributeName + "_22");
        editorTemplate -label ($szAttributeData[0] + "_23") -adc ($szAttributeName + "_23");

        editorTemplate -label ($szAttributeData[0] + "_30") -adc ($szAttributeName + "_30");
        editorTemplate -label ($szAttributeData[0] + "_31") -adc ($szAttributeName + "_31");
        editorTemplate -label ($szAttributeData[0] + "_32") -adc ($szAttributeName + "_32");
        editorTemplate -label ($szAttributeData[0] + "_33") -adc ($szAttributeName + "_33");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Color")
    {
        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "ColorA")
    {
        editorTemplate -label $szAttributeData[0] -adc $szAttributeName;
        editorTemplate -label ($szAttributeData[0] + "_Alpha") -adc ($szAttributeName + "_Alpha");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    else if($szAttributeData[2] == "Texture")
    {
        editorTemplate -label ($szAttributeData[0] + "_Texture") -adc ($szAttributeName + "_Texture");
        editorTemplate -label ($szAttributeData[0] + "_Filter") -adc ($szAttributeName + "_Filter");
        editorTemplate -s ($szAttributeData[0] + "_TempUVSet");
        editorTemplate -label ($szAttributeData[0] + "_FlipBook") -adc ($szAttributeName + "_FlipBook");
        editorTemplate -label ($szAttributeData[0] + "_FlipBookStartFrame") -adc ($szAttributeName + "_FlipBookStartFrame");
        editorTemplate -label ($szAttributeData[0] + "_FlipBookEndFrame") -adc ($szAttributeName + "_FlipBookEndFrame");
        editorTemplate -label ($szAttributeData[0] + "_FlipBookFramesPerSecond") -adc ($szAttributeName + "_FlipBookFramesPerSecond");
        editorTemplate -label ($szAttributeData[0] + "_FlipBookStartTime") -adc ($szAttributeName + "_FlipBookStartTime");
        editorTemplate -label ($szAttributeData[0] + "_FlipBookCycleType") -adc ($szAttributeName + "_FlipBookCycleType");
        editorTemplate -s ($szAttributeData[0] + "_Map");
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }

    // Check for an Array Type
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);
    
    if ($szArrayInfo[0] == "Array")
    {
        MyImmerseCreatePixelShaderArrayAttributeUI($szNodeName, $szShaderName, $szAttribute);
Cr8zyTracerOut("MyImmerseCreatePixelShaderAttributeUI", "", "");
        return;
    }
    
    
    // Give a Warning because the attrribute wasn't handled
    warning ("Unknown Attribute Type:: Name=" + $szAttributeName + " Type=" + $szAttributeData[1]);
}
//***************************************************************************
global proc MyImmerseCreatePixelShaderArrayAttributeUI(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmerseCreatePixelShaderArrayAttributeUI", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
//  print ("MyImmerseCreatePixelShaderArrayAttributeUI\n");
    int $iLoop;
    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Array,type,#Elements|DefaultValue|IsRanged|Min|Max
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);

    
    string $szSubType = $szArrayInfo[1];
    int $iNumElements = $szArrayInfo[2];
    int $iDefaultBase = 3;
    int $iElementSize = 1;
    int $iRanged = 3 + ($iNumElements * $iElementSize);
    int $iMinBase = $iRanged + 1;
    int $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    string $szExtraAttributeName;

    if ($szSubType == "String")
    {
//      print("String " + $szAttributeName + "\n");
        print("Error String Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if($szSubType == "Boolean")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop) -adc ($szAttributeName + "_" + $iLoop);
        }
    }
    
    else if($szSubType == "UnsignedInt")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop) -adc ($szAttributeName + "_" + $iLoop);
        }
    }
    else if ($szSubType == "Float")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop) -adc ($szAttributeName + "_" + $iLoop);
        }
    }
    else if ($szSubType == "Point2")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_X") -adc ($szAttributeName + "_" + $iLoop + "_1");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Y") -adc ($szAttributeName + "_" + $iLoop + "_2");
        }
    }
    else if ($szSubType == "Point3")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_X") -adc ($szAttributeName + "_" + $iLoop + "_1");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Y") -adc ($szAttributeName + "_" + $iLoop + "_2");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Z") -adc ($szAttributeName + "_" + $iLoop + "_3");
        }
    }
    else if ($szSubType == "Point4")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_X") -adc ($szAttributeName + "_" + $iLoop + "_1");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Y") -adc ($szAttributeName + "_" + $iLoop + "_2");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Z") -adc ($szAttributeName + "_" + $iLoop + "_3");
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_W") -adc ($szAttributeName + "_" + $iLoop + "_4");
        }
    }
    else if ($szSubType == "Matrix")
    {
        print("Error Matrix Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Transform")
    {
        print("Error Transform Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Color")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop) -adc ($szAttributeName + "_" + $iLoop);
        }
    }
    else if ($szSubType == "ColorA")
    {
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop) -adc ($szAttributeName + "_" + $iLoop);
            editorTemplate -label ($szAttributeData[0] + "_" + $iLoop + "_Alpha") -adc ($szAttributeName + "_" + $iLoop + "_Alpha");
        }
    }
    
    else if ($szSubType == "Matrix")
    {
        print("Error Matrix Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Texture")
    {
        print("Error Texture Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Float8")
    {
        print("Error Float8 Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Float12")
    {
        print("Error float12 Array type Unsupported:: " + $szAttributeName + "\n");
    }
    else if ($szSubType == "Array")
    {
        print("Error Array of Arrays type Unsupported:: " + $szAttributeName + "\n");
    }
Cr8zyTracerOut("MyImmerseCreatePixelShaderArrayAttributeUI", "", "");
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyShaderName(string $szNodeName, int $iShowWarning)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyShaderName", {"$szNodeName", "$iShowWarning"}, {"" + $szNodeName, "" + $iShowWarning});
    string $szShaderName = `getAttr ($szNodeName + ".PixelShaderName")`;

    if($szShaderName == "")
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyShaderName", "", "");
        return 0;
    }

    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
        if($iShowWarning == 1)
        {
            warning ( $szNodeName + " references a Gamebryo Shader (" + $szShaderName + ") which was not found.");
        }

Cr8zyTracerOut("MyImmersePixelShaderVerifyShaderName", "", "");
        return 1;
    }

Cr8zyTracerOut("MyImmersePixelShaderVerifyShaderName", "", "");
    return 0;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyAttributes(string $szNodeName, int $iShowWarning)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyAttributes", {"$szNodeName", "$iShowWarning"}, {"" + $szNodeName, "" + $iShowWarning});
    string $szShaderName = `getAttr ($szNodeName + ".PixelShaderName")`;

    if($szShaderName == "")
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttributes", "", "");
        return 0;
    }

    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttributes", "", "");
        return 0;
    }

    int $iLoop = 0;
    int $iNumAttributes = MyImmersePixelShaderGetNumAttributes($szShaderEntry);
    int $iTotalExpectedAttributes = 0;

    // Check each attribute to verify it is correct
    for($iLoop = 0; $iLoop < $iNumAttributes; $iLoop++)
    {
        // This is the general form of all attributes
        // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max
        string $szAttribute = MyImmersePixelShaderGetAttribute($szShaderEntry, $iLoop);

        int $iExtraAttributes = MyImmersePixelShaderVerifyAttribute($szNodeName, $szShaderName, $szAttribute);

        if($iExtraAttributes == 0)
        {
            if($iShowWarning == 1)
            {
                warning ( $szNodeName + " has a Gamebryo Shader (" + $szShaderName + ") attributes do not match the Gamebryo Shader Definition found.");
            }
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttributes", "", "");
            return 1;
        }

        $iTotalExpectedAttributes = $iTotalExpectedAttributes + $iExtraAttributes;
            
    }

    // Count the attributes to make sure there are not extras.
    string $szAttributes[] = `listAttr -ud $szNodeName`;
    int $iNumFound = 0;

    for($iLoop = 0; $iLoop < size($szAttributes); $iLoop++)
    {
        if(`gmatch $szAttributes[$iLoop] "Ni_PixelShaderAttribute_*"` == 1)
        {
            $iNumFound = $iNumFound + 1;
        }
    }

    if($iNumFound != $iTotalExpectedAttributes)
    {
        if($iShowWarning == 1)
        {
            warning ( $szNodeName + " has a Gamebryo Shader (" + $szShaderName + ") attributes do not match the Gamebryo Shader Definition found.");
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttributes", "", "");
        return 1;
    }

Cr8zyTracerOut("MyImmersePixelShaderVerifyAttributes", "", "");
    return 0;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyAttribute(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyAttribute", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
//  print ("MyImmerseCreatePixelShaderVerifyAttribute\n");

    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];
    string $szNodeAttrName = ($szNodeName + "." + $szAttributeName);


    // This is the general form of all attributes
    // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max
    if($szAttributeData[2] == "String")
    {
//      print ("String UI\n");

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if(`getAttr -type $szNodeAttrName` != "string")
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 1;
    }
    else if($szAttributeData[2] == "Boolean")
    {
//      print ("Boolean UI\n");

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if(`getAttr -type $szNodeAttrName` != "bool")
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 1;
    }
    else if($szAttributeData[2] == "UnsignedInt")
    {
//      print("UnsignedInt UI\n");
        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if(`getAttr -type $szNodeAttrName` != "long")
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 1;
    }
    else if($szAttributeData[2] == "Float")
    {
//      print("float UI\n");

        if(`attributeExists $szAttributeName $szNodeName` == 0)
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if(`getAttr -type $szNodeAttrName` != "float")
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 1;
    }
    else if($szAttributeData[2] == "Point2")
    {
        if((`attributeExists ($szAttributeName + "_1") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_2") $szNodeName` == 0))
        {
            warning ("Attribute Name:: Name=" + $szAttributeName);
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_1")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_2")` != "float"))   
        {
            warning ("Attribute Type:: Name=" + $szAttributeName);

Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 2;

    }
    else if($szAttributeData[2] == "Point3")
    {
        if((`attributeExists ($szAttributeName + "_1") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_2") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_3") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_1")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_2")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_3")` != "float"))   
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 3;
    }
    else if($szAttributeData[2] == "Point4")
    {
        if((`attributeExists ($szAttributeName + "_1") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_2") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_3") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_4") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_1")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_2")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_3")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_4")` != "float"))   
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 4;
    }
    else if($szAttributeData[2] == "Matrix")
    {

        if((`attributeExists ($szAttributeName + "_00") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_01") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_02") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_10") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_11") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_12") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_20") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_21") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_22") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_00")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_01")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_02")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_10")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_11")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_12")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_20")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_21")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_22")` != "float"))  
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 9;
    }
    else if($szAttributeData[2] == "Transform")
    {

        if((`attributeExists ($szAttributeName + "_00") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_01") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_02") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_03") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_10") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_11") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_12") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_13") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_20") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_21") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_22") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_23") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_30") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_31") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_32") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_33") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_00")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_01")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_02")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_03")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_10")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_11")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_12")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_13")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_20")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_21")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_22")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_23")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_30")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_31")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_32")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_33")` != "float"))  
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 16;
    }
    else if($szAttributeData[2] == "Color")
    {
        if((`attributeExists $szAttributeName $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Red") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Green") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Blue") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type $szNodeAttrName` != "float3") ||
           (`getAttr -type ($szNodeAttrName + "Red")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "Green")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "Blue")` != "float")) 
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 4;
    }
    else if($szAttributeData[2] == "ColorA")
    {
        if((`attributeExists $szAttributeName $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Red") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Green") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "Blue") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_Alpha") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type $szNodeAttrName` != "float3") ||
           (`getAttr -type ($szNodeAttrName + "Red")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "Green")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "Blue")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_Alpha")` != "float"))   
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 5;
    }
    else if($szAttributeData[2] == "Texture")
    {
        if((`attributeExists ($szAttributeName + "_Texture") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_TextureRed") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_TextureGreen") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_TextureBlue") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_Filter") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_TempUVSet") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBook") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBookStartFrame") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBookEndFrame") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBookFramesPerSecond") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBookStartTime") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_FlipBookCycleType") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_Map") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_Texture")` != "float3") ||
           (`getAttr -type ($szNodeAttrName + "_TextureRed")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_TextureGreen")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_TextureBlue")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_Filter")` != "enum") ||
           (`getAttr -type ($szNodeAttrName + "_TempUVSet")` != "enum") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBook")` != "bool") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBookStartFrame")` != "short") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBookEndFrame")` != "short") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBookFramesPerSecond")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBookStartTime")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_FlipBookCycleType")` != "enum") ||  
           (`getAttr -type ($szNodeAttrName + "_Map")` != "char"))  
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 13;
    }
    else if($szAttributeData[2] == "Float8")
    {

        if((`attributeExists ($szAttributeName + "_0") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_1") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_2") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_3") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_4") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_5") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_6") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_7") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_0")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_1")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_2")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_3")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_4")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_5")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_6")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_7")` != "float"))   
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 8;
    }
    else if($szAttributeData[2] == "Float12")
    {

        if((`attributeExists ($szAttributeName + "_0") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_1") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_2") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_3") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_4") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_5") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_6") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_7") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_8") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_9") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_10") $szNodeName` == 0) ||
           (`attributeExists ($szAttributeName + "_11") $szNodeName` == 0))
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        if((`getAttr -type ($szNodeAttrName + "_0")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_1")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_2")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_3")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_4")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_5")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_6")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_7")` != "float") || 
           (`getAttr -type ($szNodeAttrName + "_8")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_9")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_10")` != "float") ||
           (`getAttr -type ($szNodeAttrName + "_11")` != "float"))  
        {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
            return 0;
        }

        // return the number of Extra Attributes which represents this Gamebryo Shader Attribute
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return 12;
    }
    
    // Check for an Array Type
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);
    
    if ($szArrayInfo[0] == "Array")
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
        return MyImmersePixelShaderVerifyArrayAttribute($szNodeName, $szShaderName, $szAttribute);
    }
    else
    {
        warning ("Unknown Attribute Type:: Name=" + $szAttributeName + " Type=" + $szAttributeData[1]);
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyAttribute", "", "");
    return 0;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyArrayAttributeExtraData( string $szNodeName, 
    string $szExtraAttributeName, string $szAttrType)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyArrayAttributeExtraData", {"$szNodeName", "$szExtraAttributeName", "$szAttrType"}, {"" + $szNodeName, "" + $szExtraAttributeName, "" + $szAttrType});

    if(`attributeExists $szExtraAttributeName $szNodeName` == 0)
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttributeExtraData", "", "");
        return 0;
    }
    
    if(`getAttr -type ($szNodeName + "." + $szExtraAttributeName)` != $szAttrType)
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttributeExtraData", "", "");
        return 0;
    }

Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttributeExtraData", "", "");
    return 1;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyArrayAttribute(string $szNodeName, string $szShaderName, string $szAttribute)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyArrayAttribute", {"$szNodeName", "$szShaderName", "$szAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute});
    int $iLoop;
    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Array,type,#Elements|DefaultValue|IsRanged|Min|Max
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);

    
    string $szSubType = $szArrayInfo[1];
    int $iNumElements = $szArrayInfo[2];
    int $iDefaultBase = 3;
    int $iElementSize = 1;
    int $iRanged = 3 + ($iNumElements * $iElementSize);
    int $iMinBase = $iRanged + 1;
    int $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    string $szExtraAttributeName;

    if ($szSubType == "String")
    {
//      print("String " + $szAttributeName + "\n");
        print("Error String Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    else if($szSubType == "Boolean")
    {
//      print ("Boolean UI\n");

        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop), "bool") == 0)
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return $iNumElements;
    }
    else if($szSubType == "UnsignedInt")
    {
//      print ("UnsignedInt UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop), "long") == 0)
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return $iNumElements;
    }   
    else if ($szSubType == "Float")
    {
//      print ("Float UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop), "float") == 0)
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return $iNumElements;
    }
    
    else if ($szSubType == "Point2")
    {
//      print ("Point2 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_1"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_2"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 2);
    }    
    
    else if ($szSubType == "Point3")
    {
//      print ("Point3 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_1"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_2"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_3"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 3);
    }    
    else if ($szSubType == "Point4")
    {
//      print ("Point4 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_1"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_2"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_3"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_4"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 4);
    }    
    else if ($szSubType == "Point4")
    {
//      print ("Point4 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_1"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_2"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_3"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_4"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 4);
    }  
    else if ($szSubType == "Color")
    {
//      print ("Color UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop), "float3") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Red"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Green"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Blue"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 4);
    }    
    else if ($szSubType == "ColorA")
    {
//      print ("ColorA UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop), "float3") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Red"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Green"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "Blue"), "float") == 0) ||
                 (MyImmersePixelShaderVerifyArrayAttributeExtraData($szNodeName, ($szAttributeName + "_" + $iLoop + "_Alpha"), "float") == 0))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
                return 0;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return ($iNumElements * 5);
    }    
    if ($szSubType == "Matrix")
    {
//      print("Matrix " + $szAttributeName + "\n");
        print("Error Matrix Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Transform")
    {
//      print("Transform " + $szAttributeName + "\n");
        print("Error Transform Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Texture")
    {
//      print("Texture " + $szAttributeName + "\n");
        print("Error Texture Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Float8")
    {
//      print("Float8 " + $szAttributeName + "\n");
        print("Error Float8 Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Float12")
    {
//      print("Float12 " + $szAttributeName + "\n");
        print("Error Float12 Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Array")
    {
//      print("Array " + $szAttributeName + "\n");
        print("Error Array of  Array types Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
        return 0;
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayAttribute", "", "");
    return 0;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyExtraAttributeExists(
    string $szNodeName, string $szExtraAttribute, 
    string $szAttributeName, string $szAttributeType)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyExtraAttributeExists", {"$szNodeName", "$szExtraAttribute", "$szAttributeName", "$szAttributeType"}, {"" + $szNodeName, "" + $szExtraAttribute, "" + $szAttributeName, "" + $szAttributeType});
    if($szExtraAttribute != $szAttributeName)
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttributeExists", "", "");
        return 0;
    }

    if(`getAttr -type ($szNodeName + "." + $szExtraAttribute)` != $szAttributeType)
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttributeExists", "", "");
        return 0;
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttributeExists", "", "");
    return 1;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyExtraAttribute(string $szNodeName, string $szShaderName, string $szAttribute, string $szExtraAttribute)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyExtraAttribute", {"$szNodeName", "$szShaderName", "$szAttribute", "$szExtraAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute, "" + $szExtraAttribute});
//  print ("MyImmerseCreatePixelShaderVerifyAttribute\n");

    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];
    string $szNodeAttrName = ($szNodeName + "." + $szExtraAttribute);


    // This is the general form of all attributes
    // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max
    if($szAttributeData[2] == "String")
    {
//      print ("String UI\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
        return MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "string");
    }
    else if($szAttributeData[2] == "Boolean")
    {
//      print ("Boolean UI\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
        return MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "Boolean");
    }
    else if($szAttributeData[2] == "UnsignedInt")
    {
//      print ("UnsignedInt UI\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
        return MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "long");
    }
    else if($szAttributeData[2] == "Float")
    {
//      print("float UI\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
        return MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "float");
    }
    else if($szAttributeData[2] == "Point2")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_2"), "float"));
    }
    else if($szAttributeData[2] == "Point3")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_2"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_3"), "float"));
    }
    else if($szAttributeData[2] == "Point4")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_2"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_3"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_4"), "float"));
    }
    else if($szAttributeData[2] == "Matrix")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_00"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_01"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_02"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_10"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_11"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_12"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_20"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_21"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_21"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_22"), "float"));
    }
    else if($szAttributeData[2] == "Transform")
    {

        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_00"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_01"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_02"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_03"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_10"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_11"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_12"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_13"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_20"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_21"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_22"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_23"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_30"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_31"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_32"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_33"), "float"));
    }
    else if($szAttributeData[2] == "Color")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "float3") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Red"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Green"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Blue"), "float"));
    }
    else if($szAttributeData[2] == "ColorA")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, $szAttributeName, "float3") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Red"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Green"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "Blue"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_Alpha"), "float"));
    }
    else if($szAttributeData[2] == "Texture")
    {
        return (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_Texture"), "float3") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_TextureRed"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_TextureGreen"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_TextureBlue"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_TextureBlue"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_Filter"), "enum") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_TempUVSet"), "enum") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBook"), "bool") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBookStartFrame"), "short") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBookEndFrame"), "short") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBookFramesPerSecond"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBookStartTime"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_FlipBookCycleType"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_Map"), "char"));
    }
    
    // Check for an Array Type
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);
    
    if ($szArrayInfo[0] == "Array")
    {
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
        return MyImmersePixelShaderVerifyArrayAttribute($szNodeName, $szShaderName, $szAttribute);
    }
    else
    {
        warning ("Unknown Attribute Type:: Name=" + $szAttributeName + " Type=" + $szAttributeData[1]);
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyExtraAttribute", "", "");
    return 0;
}
//***************************************************************************
global proc int MyImmersePixelShaderVerifyArrayExtraAttribute(string $szNodeName, string $szShaderName, string $szAttribute, string $szExtraAttribute)
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyArrayExtraAttribute", {"$szNodeName", "$szShaderName", "$szAttribute", "$szExtraAttribute"}, {"" + $szNodeName, "" + $szShaderName, "" + $szAttribute, "" + $szExtraAttribute});
    int $iLoop;
    string $szAttributeData[];
    tokenize($szAttribute, "|", $szAttributeData);

    string $szAttributeName = "Ni_PixelShaderAttribute_" + $szShaderName + "_" + $szAttributeData[0];

    // This is the general form of all attributes
    // Attribute = Name|Description|Array,type,#Elements|DefaultValue|IsRanged|Min|Max
    string $szArrayInfo[];
    tokenize($szAttributeData[2],",", $szArrayInfo);

    
    string $szSubType = $szArrayInfo[1];
    int $iNumElements = $szArrayInfo[2];
    int $iDefaultBase = 3;
    int $iElementSize = 1;
    int $iRanged = 3 + ($iNumElements * $iElementSize);
    int $iMinBase = $iRanged + 1;
    int $iMaxBase = $iMinBase + ($iNumElements * $iElementSize);
    string $szExtraAttributeName;

    if ($szSubType == "String")
    {
//      print("String " + $szAttributeName + "\n");
        print("Error String Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    else if($szSubType == "Boolean")
    {
//      print ("Boolean UI\n");

        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop), "Bool"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    else if($szSubType == "UnsignedInt")
    {
//      print ("UnsignedInt UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop), "long"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }   
    else if($szSubType == "Float")
    {
//      print ("Float UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop), "float"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }   
    else if($szSubType == "Point2")
    {
//      print ("Point2 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_2"), "float"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }   
    else if($szSubType == "Point3")
    {
//      print ("Point3 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_2"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_3"), "float"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }   
    else if($szSubType == "Point4")
    {
//      print ("Point4 UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_1"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_2"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_3"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_4"), "float"))
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    else if ($szSubType == "Color")
    {
//      print ("Color UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if (MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop), "float3") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Red"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Green"), "float") ||
                MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Blue"), "float") )
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }    
    else if ($szSubType == "ColorA")
    {
//      print ("ColorA UI\n");
        for ($iLoop = 0; $iLoop < $iNumElements; $iLoop++)
        {
            if ( MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop), "float3") ||
                 MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Red"), "float") ||
                 MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Green"), "float") ||
                 MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "Blue"), "float") ||
                 MyImmersePixelShaderVerifyExtraAttributeExists($szNodeName, $szExtraAttribute, ($szAttributeName + "_" + $iLoop + "_Alpha"), "float") )
            {
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
                return 1;
            }
        }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }    
    if ($szSubType == "Matrix")
    {
//      print("Matrix " + $szAttributeName + "\n");
        print("Error Matrix Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Transform")
    {
//      print("Transform " + $szAttributeName + "\n");
        print("Error Transform Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Texture")
    {
//      print("Texture " + $szAttributeName + "\n");
        print("Error Texture Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Float8")
    {
//      print("Float8 " + $szAttributeName + "\n");
        print("Error Float8 Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Float12")
    {
//      print("Float12 " + $szAttributeName + "\n");
        print("Error Float12 Array type Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
    if ($szSubType == "Array")
    {
//      print("Array " + $szAttributeName + "\n");
        print("Error Array of  Array types Unsupported:: " + $szAttributeName + "\n");
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
        return 0;
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyArrayExtraAttribute", "", "");
    return 0;
}
//***************************************************************************
global proc AEMultiRelinkPixelShaderAttributes(string $szNodeName)
{
Cr8zyTracerIn("AEMultiRelinkPixelShaderAttributes", {"$szNodeName"}, {"" + $szNodeName});
    string $szShaderName = `getAttr ($szNodeName + ".PixelShaderName")`;

    if($szShaderName == "")
    {
Cr8zyTracerOut("AEMultiRelinkPixelShaderAttributes", "", "");
        return;
    }

    string $szShaderEntry = MyImmerseGetPixelShaderEntry($szShaderName);

    // Check for the entry not being found
    if($szShaderEntry == "")
    {
Cr8zyTracerOut("AEMultiRelinkPixelShaderAttributes", "", "");
        return;
    }

    int $iLoop = 0;
    int $iNumAttributes = MyImmersePixelShaderGetNumAttributes($szShaderEntry);
    int $iTotalExpectedAttributes = 0;

    // Count the attributes to make sure there are not extras.
    string $szAttributes[] = `listAttr -ud $szNodeName`;
    int $iNumFound = 0;

    // Loop Through Each Attribute to determine if it should be deleted
    for($iLoop = 0; $iLoop < size($szAttributes); $iLoop++)
    {
        if(`gmatch $szAttributes[$iLoop] "Ni_PixelShaderAttribute_*"` == 1)
        {
            if(`attributeExists $szAttributes[$iLoop] $szNodeName` == 1)
            {
                int $iValidAttribute = 0;
                // Check each attribute to verify it is correct
                int $iPALoop = 0;

                for($iPALoop = 0; (($iPALoop < $iNumAttributes) && ($iValidAttribute == 0)); $iPALoop++)
                {
                    string $szShaderAttribute = MyImmersePixelShaderGetAttribute($szShaderEntry, $iPALoop);

                    // This is the general form of all attributes
                    // Attribute = Name|Description|Type|DefaultValue|IsRanged|Min|Max
                    $iValidAttribute = MyImmersePixelShaderVerifyExtraAttribute($szNodeName, $szShaderName, $szShaderAttribute, $szAttributes[$iLoop]);
                }

//              print ("Valid Attr " + $szAttributes[$iLoop] + " " + $iValidAttribute + "\n");

                // Delete the Attibute if it is unnecessary
                if($iValidAttribute == 0)
                {
                    deleteAttr ($szNodeName + "." + $szAttributes[$iLoop]);
                }
            }
        }
    }

    MyImmerseCreatePixelShaderAttributes($szNodeName, $szShaderName);
}
//***************************************************************************
global proc MyImmersePixelShaderVerifyAllNiMultiShaders()
{
Cr8zyTracerIn("MyImmersePixelShaderVerifyAllNiMultiShaders", {}, {});
    string $szNiMultiShaderNodes[] = `ls -l -typ NiMultiShader`;

    int $iInvalidShaderName = 0;
    int $iInvalidAttributes = 0;
        
    int $iCount = 0;
    for($iCount = 0; $iCount < size($szNiMultiShaderNodes); $iCount++)
    {
        if(MyImmersePixelShaderVerifyShaderName($szNiMultiShaderNodes[$iCount], 1) == 1)
            $iInvalidShaderName = 1;

        if(MyImmersePixelShaderVerifyAttributes($szNiMultiShaderNodes[$iCount], 1) == 1)
            $iInvalidAttributes = 1;
    }

    if(($iInvalidShaderName == 1) || ($iInvalidAttributes == 1))
    {
        MyImmersePixelShaderErrorDialog($iInvalidShaderName, $iInvalidAttributes);
    }
Cr8zyTracerOut("MyImmersePixelShaderVerifyAllNiMultiShaders", "", "");
}
//***************************************************************************
global proc MyImmersePixelShaderClearAllUnFoundShaders()
{
Cr8zyTracerIn("MyImmersePixelShaderClearAllUnFoundShaders", {}, {});
    string $szNiMultiShaderNodes[] = `ls -l -typ NiMultiShader`;

    int $iCount = 0;
    for($iCount = 0; $iCount < size($szNiMultiShaderNodes); $iCount++)
    {
        if(MyImmersePixelShaderVerifyShaderName($szNiMultiShaderNodes[$iCount], 0) == 1)
        {
            // Clear the Shader Name, ID and remove any extra attributes
            setAttr ($szNiMultiShaderNodes[$iCount] + ".PixelShaderName") -typ "string" "";
            setAttr ($szNiMultiShaderNodes[$iCount] + ".PixelShaderID") 0;

            MyImmerseRemovePixelShaderAttributes($szNiMultiShaderNodes[$iCount]);
        }
    }

    // Gray out the button we only work once
    if(`button -ex MyImmersePixelShaderClearUnkownButton` == 1)
    {
        button -e -en false MyImmersePixelShaderClearUnkownButton;
    }

    // If the other button doesn't exist the close the error dialog
    if(`button -ex MyImmersePixelShaderRelinkAttributesButton` == 0)
    {
        deleteUI Ni_PixelShaderErrorWindow;
Cr8zyTracerOut("MyImmersePixelShaderClearAllUnFoundShaders", "", "");
        return;
    }

    // delete the dialog if the button is already grayed out
    if(`button -q -en MyImmersePixelShaderRelinkAttributesButton` == 0)
    {
        deleteUI Ni_PixelShaderErrorWindow;
Cr8zyTracerOut("MyImmersePixelShaderClearAllUnFoundShaders", "", "");
        return;
    }

}
//***************************************************************************
global proc MyImmersePixelShaderRelinkAllInvalidShaders()
{
Cr8zyTracerIn("MyImmersePixelShaderRelinkAllInvalidShaders", {}, {});
    string $szNiMultiShaderNodes[] = `ls -l -typ NiMultiShader`;

    int $iCount = 0;
    for($iCount = 0; $iCount < size($szNiMultiShaderNodes); $iCount++)
    {
        if((MyImmersePixelShaderVerifyShaderName($szNiMultiShaderNodes[$iCount], 0) == 0) &&
           (MyImmersePixelShaderVerifyAttributes($szNiMultiShaderNodes[$iCount], 0) == 1))
        {
            AEMultiRelinkPixelShaderAttributes($szNiMultiShaderNodes[$iCount]);
        }
    }

    // Gray out the button we only work once
    if(`button -ex MyImmersePixelShaderRelinkAttributesButton` == 1)
    {
        button -e -en false MyImmersePixelShaderRelinkAttributesButton;
    }

    // If the other button doesn't exist the close the error dialog
    if(`button -ex MyImmersePixelShaderClearUnkownButton` == 0)
    {
        deleteUI Ni_PixelShaderErrorWindow;
Cr8zyTracerOut("MyImmersePixelShaderRelinkAllInvalidShaders", "", "");
        return;
    }

    // delete the dialog if the button is already grayed out
    if(`button -q -en MyImmersePixelShaderClearUnkownButton` == 0)
    {
        deleteUI Ni_PixelShaderErrorWindow;
Cr8zyTracerOut("MyImmersePixelShaderRelinkAllInvalidShaders", "", "");
        return;
    }
}
//***************************************************************************
global proc MyImmersePixelShaderErrorDialog(int $iInvalidShader, int $iInvalidAttributes)
{
Cr8zyTracerIn("MyImmersePixelShaderErrorDialog", {"$iInvalidShader", "$iInvalidAttributes"}, {"" + $iInvalidShader, "" + $iInvalidAttributes});
    if(MyImmerseWindowExists("Ni_PixelShaderErrorWindow"))
    {
        deleteUI Ni_PixelShaderErrorWindow;
    }

    if (GetGamebryoRunSilent())
        return;

    window -title "Gamebryo Shader Error" -widthHeight 400 250 Ni_PixelShaderErrorWindow;

    columnLayout;


        text -label "";

        if($iInvalidShader == 1)
        {
            text -label "     The scene graph contains references to Unkown Gamebryo Shaders.\n Please check the script output window for more details.";
            text -label "";
        }

        if($iInvalidAttributes == 1)
        {
            text -label "     The scene graph contains Gamebryo Shaders with invalid attributes.\n Please check the script output window for more details.";
            text -label "";
        }

        if($iInvalidShader == 1)
        {
            rowLayout -nc 2;
                
                text -label "";

                button 
                    -label "Clear All Unknown Shaders" 
                    -c "MyImmersePixelShaderClearAllUnFoundShaders"
                    MyImmersePixelShaderClearUnkownButton;

            setParent ..; // RowLayout
         
            text -label "";
        }

        if($iInvalidAttributes == 1)
        {
            rowLayout -nc 2;
                
                text -label "";

                button 
                    -label "Relink All Invalid Shader Attributes" 
                    -c "MyImmersePixelShaderRelinkAllInvalidShaders"
                    MyImmersePixelShaderRelinkAttributesButton;

                setParent ..; // RowLayout
            text -label "";
        }

        rowLayout -nc 2;
                
            text -label "";

            button 
                -label "Leave the Gamebryo Shader Data." 
                -c "deleteUI Ni_PixelShaderErrorWindow"
                MyImmersePixelShaderLeavePixelDataButton;

        setParent ..; // RowLayout

    setParent ..; // columnLayout

    showWindow Ni_PixelShaderErrorWindow;
Cr8zyTracerOut("MyImmersePixelShaderErrorDialog", "", "");
}


/*
// Shader Entries = Name;Description;Implementations;Attributes
// Implementations = Num Implementations|Name0|Desc0|Name1|Desc1......
// Attributes = NumAttributes#Attr0#Attr1#Attr2......
// Attribute = Name|Description|Type|Default|IsRanged|Min|Max

optionVar -sv "MyImmersePixelShaderData" "Thurmal_Vision;Thurmal Vision Description;1|ImpName|ImpDesc;0";
optionVar -sva "MyImmersePixelShaderData" "String_Test;String Description;1|ImpName|ImpDesc;1#SName|ADesc|String|AttDefault";
optionVar -sva "MyImmersePixelShaderData" "Boolean_Test;Boolean Description;1|ImpName|ImpDesc;1#BName|BDesc|Boolean|1";
optionVar -sva "MyImmersePixelShaderData" "Float_Test;Float Description;1|ImpName|ImpDesc;1#FName|FDesc|Float|1.0|0";
optionVar -sva "MyImmersePixelShaderData" "Point2_Test;Point2 Description;1|ImpName|ImpDesc;1#P2Name|P2Desc|Point2|1.0|1.0|1|0.0|0.0|5.0|5.0";
optionVar -sva "MyImmersePixelShaderData" "Point3_Test;Point3 Description;1|ImpName|ImpDesc;1#P3Name|P3Desc|Point3|1.0|1.0|1.0|1|0.0|0.0|0.0|5.0|5.0|5.0";
optionVar -sva "MyImmersePixelShaderData" "Point4_Test;Point4 Description;1|ImpName|ImpDesc;1#P4Name|P4Desc|Point4|1.0|1.0|1.0|1.0|1|0.0|0.0|0.0|0.0|5.0|5.0|5.0|5.0";
optionVar -sva "MyImmersePixelShaderData" "Matrix_Test;Matrix Description;1|ImpName|ImpDesc;1#MName|MDesc|Matrix";
optionVar -sva "MyImmersePixelShaderData" "Transform_Test;Transform Description;1|ImpName|ImpDesc;1#TName|TDesc|Transform";
optionVar -sva "MyImmersePixelShaderData" "Color_Test;Color Description;1|ImpName|ImpDesc;1#ColorName|ColorDesc|Color|1.0|1.0|1.0|1|0.0|0.0|0.0|1.0|1.0|1.0";
optionVar -sva "MyImmersePixelShaderData" "ColorA_Test;ColorA Description;1|ImpName|ImpDesc;1#ColorAName|ColorADesc|ColorA|1.0|1.0|1.0|1.0|1|0.0|0.0|0.0|0.0|1.0|1.0|1.0|1.0";
optionVar -sva "MyImmersePixelShaderData" "Texture_Test;Texture Description;1|ImpName|ImpDesc;1#ColorTextureName|TDesc|Texture|0|DefaultTexture";


addAttr -ln NiData_DoubleXYZ -nc 3 -at double3  -uac pSphere1;
addAttr -ln NiData_DoubleXYZX -at double -p NiData_DoubleXYZ pSphere1;
addAttr -ln NiData_DoubleXYZY -at double -p NiData_DoubleXYZ pSphere1;
addAttr -ln NiData_DoubleXYZZ -at double -p NiData_DoubleXYZ pSphere1;
*/
